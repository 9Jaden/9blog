<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue基础知识🔥 | 嘉梁的博客</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/9blog/icon.jpg">
    <meta name="description" content="Welcome!">
    
    <link rel="preload" href="/9blog/assets/css/0.styles.e39160fb.css" as="style"><link rel="preload" href="/9blog/assets/js/app.3e8fe7ca.js" as="script"><link rel="preload" href="/9blog/assets/js/3.4ae95a2d.js" as="script"><link rel="preload" href="/9blog/assets/js/1.ac641155.js" as="script"><link rel="preload" href="/9blog/assets/js/28.45a89b98.js" as="script"><link rel="prefetch" href="/9blog/assets/js/10.f32e5926.js"><link rel="prefetch" href="/9blog/assets/js/11.a32291ec.js"><link rel="prefetch" href="/9blog/assets/js/12.854853e6.js"><link rel="prefetch" href="/9blog/assets/js/13.d58b78e1.js"><link rel="prefetch" href="/9blog/assets/js/14.b74e23f1.js"><link rel="prefetch" href="/9blog/assets/js/15.36f6770d.js"><link rel="prefetch" href="/9blog/assets/js/16.542bf7be.js"><link rel="prefetch" href="/9blog/assets/js/17.e1b738e9.js"><link rel="prefetch" href="/9blog/assets/js/18.f00a61c5.js"><link rel="prefetch" href="/9blog/assets/js/19.dddc4cb9.js"><link rel="prefetch" href="/9blog/assets/js/20.895aaf01.js"><link rel="prefetch" href="/9blog/assets/js/21.b6755c35.js"><link rel="prefetch" href="/9blog/assets/js/22.38b1460c.js"><link rel="prefetch" href="/9blog/assets/js/23.21ba7001.js"><link rel="prefetch" href="/9blog/assets/js/24.38298f63.js"><link rel="prefetch" href="/9blog/assets/js/25.0834d742.js"><link rel="prefetch" href="/9blog/assets/js/26.f7a3dd00.js"><link rel="prefetch" href="/9blog/assets/js/27.b3d77e32.js"><link rel="prefetch" href="/9blog/assets/js/29.b75831cb.js"><link rel="prefetch" href="/9blog/assets/js/30.768ec0c1.js"><link rel="prefetch" href="/9blog/assets/js/31.c8818d1b.js"><link rel="prefetch" href="/9blog/assets/js/32.a8e266aa.js"><link rel="prefetch" href="/9blog/assets/js/33.b2484fc9.js"><link rel="prefetch" href="/9blog/assets/js/34.347bdff3.js"><link rel="prefetch" href="/9blog/assets/js/35.42bd7061.js"><link rel="prefetch" href="/9blog/assets/js/4.153cb639.js"><link rel="prefetch" href="/9blog/assets/js/5.aa9edc01.js"><link rel="prefetch" href="/9blog/assets/js/6.d146555e.js"><link rel="prefetch" href="/9blog/assets/js/7.80cabe8f.js"><link rel="prefetch" href="/9blog/assets/js/8.9c58261e.js"><link rel="prefetch" href="/9blog/assets/js/9.f9ada005.js">
    <link rel="stylesheet" href="/9blog/assets/css/0.styles.e39160fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>嘉梁的博客</h3> <p class="description" data-v-59e6cb88>Welcome!</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>JIALIANG</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/9blog/" class="home-link router-link-active"><img src="/9blog/avatar.jpg" alt="嘉梁的博客" class="logo"> <span class="site-name">嘉梁的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/9blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/9blog/categories/前端学习笔记/" class="nav-link"><i class="undefined"></i>
  前端学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/9blog/categories/项目简介/" class="nav-link"><i class="undefined"></i>
  项目简介
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      About嘉梁
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://weibo.com/u/5532906301" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  个人微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/9blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/9blog/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    JIALIANG
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>25</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>49</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/9blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/9blog/categories/前端学习笔记/" class="nav-link"><i class="undefined"></i>
  前端学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/9blog/categories/项目简介/" class="nav-link"><i class="undefined"></i>
  项目简介
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      About嘉梁
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://weibo.com/u/5532906301" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  个人微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/9blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>Vue基础知识🔥</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>JIALIANG</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">Vue基础知识🔥</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>JIALIANG</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2/2/2023</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>Vue</span></i></div></div> <div class="theme-reco-content content__default"><h1 id="vue"><a href="#vue" class="header-anchor">#</a> VUE</h1> <p>vue.js是用于创建用户界面的开源JS框架，创建单页面应用SPA的web应用框架。</p> <p>核心特性：数据驱动(MVVM)、 组件化、指令系统、虚拟dom</p> <h3 id="vue和react对比"><a href="#vue和react对比" class="header-anchor">#</a> VUE和REACT对比</h3> <p><strong>相同点</strong></p> <ul><li>都有组件化思想</li> <li>都支持服务器端渲染</li> <li>都有Virtual DOM（虚拟dom）</li> <li>数据驱动视图</li> <li>都有支持native的方案：<code>Vue</code>的<code>weex</code>、<code>React</code>的<code>React native</code></li> <li>都有自己的构建工具：<code>Vue</code>的<code>vue-cli</code>、<code>React</code>的<code>Create React App</code></li></ul> <p><strong>区别</strong></p> <ul><li>数据流向的不同。<code>react</code>从诞生开始就推崇单向数据流，而<code>Vue</code>是双向数据流</li> <li>数据变化的实现原理不同。<code>react</code>使用的是不可变数据，而<code>Vue</code>使用的是可变的数据</li> <li>组件化通信的不同。<code>react</code>中我们通过使用回调函数来进行通信的，而<code>Vue</code>中子组件向父组件传递消息有两种方式：事件和回调函数</li> <li>diff算法不同。<code>react</code>主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。<code>Vue</code> 使用双向指针，边对比，边更新DOM</li></ul> <h3 id="指令系统"><a href="#指令系统" class="header-anchor">#</a> 指令系统</h3> <p>解释：指令 (Directives) 是带有 v- 前缀的特殊属性作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</p> <ul><li>常用的指令
<ul><li>条件渲染指令 <code>v-if</code></li> <li>列表渲染指令<code>v-for</code></li> <li>属性绑定指令<code>v-bind</code> <strong>:</strong></li> <li>事件绑定指令<code>v-on</code> <strong>@</strong></li> <li>双向数据绑定指令<code>v-model</code></li></ul></li></ul> <p>没有指令之前我们是怎么做的？是不是先要获取到DOM然后在....干点啥</p> <h3 id="spa"><a href="#spa" class="header-anchor">#</a> SPA</h3> <p>所有必要的代码（<code>HTML</code>、<code>JavaScript</code>和<code>CSS</code>）都通过单个页面的加载而检索，或者根据需要（通常是为响应用户操作）<strong>动态装载</strong>适当的资源并添加到页面页面。在任何时间点都不会重新加载，也不会将控制转移到其他页面。</p> <p>好处：页面切换速度快，无需重新加载页面</p> <p>坏处：首次渲染速度慢，SEO搜索引擎优化难</p> <h4 id="首屏速度慢怎么办"><a href="#首屏速度慢怎么办" class="header-anchor">#</a> 首屏速度慢怎么办</h4> <p>在页面渲染的过程，导致加载速度慢的因素可能如下：</p> <ul><li><p>网络延时问题</p></li> <li><p>资源文件体积是否过大</p></li> <li><p>资源是否重复发送请求去加载了</p></li> <li><p>加载脚本导致渲染内容堵塞了</p> <p>常见的几种SPA首屏优化方式</p> <ul><li><p>减小入口文件体积---<strong>懒加载</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">routes</span><span class="token operator">:</span><span class="token punctuation">[</span> 
    <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'Blogs'</span><span class="token punctuation">,</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'ShowBlogs'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./components/ShowBlogs.vue'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
</code></pre></div><p>动态加载路由，以函数的形式加载路由，这样就可以把各自的路由文件分别打包，<strong>只有在解析给定的路由时，才会加载路由组件</strong></p></li> <li><p>静态资源本地缓存</p> <p>后端返回资源问题：</p> <ul><li>采用<code>HTTP</code>缓存，设置<code>Cache-Control</code>，<code>Last-Modified</code>，<code>Etag</code>等响应头</li> <li>采用<code>Service Worker</code>离线缓存</li></ul> <p>前端合理利用<code>localStorage</code></p></li> <li><p>UI框架按需加载</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Button<span class="token punctuation">,</span> Input<span class="token punctuation">,</span> Pagination<span class="token punctuation">,</span> Table<span class="token punctuation">,</span> TableColumn<span class="token punctuation">,</span> MessageBox <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'element-ui'</span><span class="token punctuation">;</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Input<span class="token punctuation">)</span>
Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Pagination<span class="token punctuation">)</span>
</code></pre></div></li> <li><p>图片资源的压缩---<strong>精灵图</strong></p></li> <li><p>组件重复打包</p> <p>假设<code>A.js</code>文件是一个常用的库，现在有多个路由使用了<code>A.js</code>文件，这就造成了重复下载</p> <p>解决方案：在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">minChunks</span><span class="token operator">:</span> <span class="token number">3</span>
</code></pre></div><p><code>minChunks</code>为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p></li> <li><p>开启GZip压缩</p></li> <li><p>使用SSR</p> <p>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器</p> <p>从头搭建一个服务端渲染是很复杂的，<code>vue</code>应用建议使用<code>Nuxt.js</code>实现服务端渲染</p></li></ul></li></ul> <h3 id="虚拟dom"><a href="#虚拟dom" class="header-anchor">#</a> 虚拟dom</h3> <p>实际上它只是一层对真实<code>DOM</code>的抽象，以<code>JavaScript</code> 对象 (<code>VNode</code> 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上</p> <p>在<code>Javascript</code>对象中，虚拟<code>DOM</code> 表现为一个 <code>Object</code>对象。并且最少包含标签名 (<code>tag</code>)、属性 (<code>attrs</code>) 和子元素对象 (<code>children</code>) 三个属性</p> <p>通过<code>VNode</code>，同样更新10个<code>DOM</code>节点，虚拟<code>DOM</code>不会立即操作<code>DOM</code>，而是将这10次更新的<code>diff</code>内容保存到本地的一个<code>js</code>对象中，最终将这个<code>js</code>对象一次性<code>attach</code>到<code>DOM</code>树上，减少 JavaScript 操作真实 DOM 的带来的性能消耗</p> <h3 id="diff算法"><a href="#diff算法" class="header-anchor">#</a> diff算法</h3> <p>一种通过同层的树节点进行比较的高效算法</p> <ul><li>比较只会在同层级进行, 不会跨层级比较</li> <li>在diff比较的过程中，循环从两边向中间比较</li></ul> <p><strong>react-diff</strong></p> <p>单链表无法使用双指针，所以无法对算法使用双指针优化</p> <p>vue2 diff算法就是进行<strong>虚拟节点对比</strong>，并返回一个patch对象，用来<strong>存储两个节点不同的地方</strong>，最后用<strong>patch记录的消息去局部更新Dom</strong>。
vue2 diff算法会比较每一个vnode,而对于一些不参与更新的元素，进行比较是有点消耗性能的。</p> <p>vue3 diff算法在初始化的时候会给每个虚拟节点添加一个patchFlags，patchFlags就是<strong>优化的标识</strong>。
只会比较patchFlags发生变化的vnode,进行更新视图，对于没有变化的元素做静态标记，在渲染的时候直接复用。</p> <h2 id="vue2和vue3区别"><a href="#vue2和vue3区别" class="header-anchor">#</a> Vue2和Vue3区别</h2> <p>diff算法不同</p> <p>生命周期不同 vue3很多on开头 mounted ---&gt; onMounted</p> <p>v-if和v-for优先级，vue3的v-if优先级高</p> <p>vue3支持多个根节点</p> <h3 id="绑定数据"><a href="#绑定数据" class="header-anchor">#</a> 绑定数据</h3> <p>绑定数据有三种方式：</p> <ul><li>插值，也就是的形式，以文本的形式和实例data中对应的属性进行绑定</li> <li>v-bind：</li> <li>v-model：</li></ul> <p>v-bind:为单向绑定，可以简写为:如<input></p> <p>而v-model:为双向绑定，主要用在表单元素中</p> <p><label><input></label></p> <p>input输入内容会更改data.name，那么相应也会改变</p> <p>当v-bind和v-model同时用在一个元素上时，它们各自的作用没变，但v-model优先级更高，而且需区分这个元素是单个的还是一组出现的</p> <h3 id="为什么data必须是函数"><a href="#为什么data必须是函数" class="header-anchor">#</a> 为什么data必须是函数</h3> <p>因为如果data是对象，则复用组件时所有数据对象指向同一个data对象，因此修改混乱；但用函数每次返回一个新的对象，引用地址不同而避免该问题。</p> <h3 id="vue-loader"><a href="#vue-loader" class="header-anchor">#</a> vue-loader</h3> <p>vue文件的加载器，把template/js/style转换成js模块</p> <h3 id="v-for中key作用"><a href="#v-for中key作用" class="header-anchor">#</a> v-for中key作用</h3> <p>给vue提示以追踪每个节点的身份，从而重用和重新排序现有元素。</p> <p>主要在虚拟DOM算法中使用，新旧nodes对比时辨识VNodes，使用key会基于key的变化重新排列元素顺序，移除key不存在的元素而不是一一对比，提高diff效率，减少开销。</p> <p>下面是不加key，默认采用就地复用原则，最小化element移动</p> <h3 id="vue的双向数据绑定原理是什么"><a href="#vue的双向数据绑定原理是什么" class="header-anchor">#</a> Vue的双向数据绑定原理是什么？</h3> <p>vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty()<strong>来劫持各个属性的</strong>setter，getter</strong>，在<strong>数据变动</strong>时发布消息给订阅者，<strong>触发相应的监听回调</strong>。主要分为以下几个步骤：</p> <blockquote><p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></blockquote> <blockquote><p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></blockquote> <blockquote><p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</p></blockquote> <blockquote><p>4、MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></blockquote> <h3 id="组件通信"><a href="#组件通信" class="header-anchor">#</a> 组件通信</h3> <h4 id="父传子"><a href="#父传子" class="header-anchor">#</a> 父传子</h4> <ol><li><strong>通过props传递</strong></li></ol> <div class="language-ini extra-class"><pre class="language-ini"><code><span class="token key attr-name">父组件： &lt;child value</span> <span class="token punctuation">=</span> <span class="token value attr-value">'传递的数据' /&gt;</span>
子组件: props['value'],接收数据,接受之后使用和data中定义数据使用方式一样
</code></pre></div><h4 id="子传父"><a href="#子传父" class="header-anchor">#</a> 子传父</h4> <ol start="2"><li><strong>自定义事件$emit</strong></li></ol> <p>在父组件中给子组件绑定一个自定义的事件，子组件通过$emit()触发该事件并传值。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code>父组件： <span class="token operator">&lt;</span>child <span class="token label symbol">@receive</span> <span class="token operator">=</span> 'receive' <span class="token operator">/</span><span class="token operator">&gt;</span>
子组件<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$<span class="token function">emit</span><span class="token punctuation">(</span>'receive<span class="token char">','</span>传递的数据'<span class="token punctuation">)</span>
</code></pre></div><ol start="3"><li><strong>ref</strong></li></ol> <ul><li>父组件在使用子组件的时候设置<code>ref</code></li> <li>父组件通过设置子组件<code>ref</code>来获取数据</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>Children ref<span class="token operator">=</span><span class="token string">&quot;foo&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">.</span>foo  <span class="token comment">// 获取子组件实例，通过子组件实例我们就能拿到对应的数据</span>
</code></pre></div><h4 id="兄弟组件传值"><a href="#兄弟组件传值" class="header-anchor">#</a> 兄弟组件传值</h4> <ol start="4"><li><strong>全局事件总线EventBus</strong></li></ol> <ul><li>通过中央通信 Vue.prototype.$bus = new Vue() 【挂载到vue实例原型上】</li></ul> <blockquote><p>A：methods :{ 函数{bus.$emit(‘自定义事件名’，数据)} 发送</p></blockquote> <blockquote><p>B：created （）{bus.$on(‘A发送过来的自定义事件名’，函数)} 进行数据接收</p></blockquote> <ol start="5"><li><strong>vuex</strong></li> <li><strong>$parent或$root</strong></li></ol> <ul><li><p>通过共同祖辈<code>$parent</code>或者<code>$root</code>搭建通信桥连</p> <p>兄弟组件</p> <div class="language- extra-class"><pre class="language-text"><code>this.$parent.on('add',this.add)
</code></pre></div><p>另一个兄弟组件</p> <div class="language- extra-class"><pre class="language-text"><code>this.$parent.emit('add')
</code></pre></div></li></ul> <h4 id="子孙组件传值"><a href="#子孙组件传值" class="header-anchor">#</a> 子孙组件传值</h4> <ol start="7"><li><strong>$attrs与$listeners</strong></li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// child：并未在props中声明foo  </span>
<span class="token operator">&lt;</span>p<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>$attrs<span class="token punctuation">.</span>foo<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>  
  
<span class="token comment">// parent  </span>
<span class="token operator">&lt;</span>HelloWorld foo<span class="token operator">=</span><span class="token string">&quot;foo&quot;</span><span class="token operator">/</span><span class="token operator">&gt;</span>  
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 给Grandson隔代传值，communication/index.vue  </span>
<span class="token operator">&lt;</span>Child2 msg<span class="token operator">=</span><span class="token string">&quot;lalala&quot;</span> @some<span class="token operator">-</span>event<span class="token operator">=</span><span class="token string">&quot;onSomeEvent&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Child2<span class="token operator">&gt;</span>  
  
<span class="token comment">// Child2做展开  </span>
<span class="token operator">&lt;</span>Grandson v<span class="token operator">-</span>bind<span class="token operator">=</span><span class="token string">&quot;$attrs&quot;</span> v<span class="token operator">-</span>on<span class="token operator">=</span><span class="token string">&quot;$listeners&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>Grandson<span class="token operator">&gt;</span>  
  
<span class="token comment">// Grandson使⽤  </span>
<span class="token operator">&lt;</span>div @click<span class="token operator">=</span><span class="token string">&quot;$emit('some-event', 'msg from grandson')&quot;</span><span class="token operator">&gt;</span>  
<span class="token punctuation">{</span><span class="token punctuation">{</span>msg<span class="token punctuation">}</span><span class="token punctuation">}</span>  
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span> 
</code></pre></div><ol start="8"><li><strong>provide与inject</strong></li></ol> <ul><li>在祖先组件定义<code>provide</code>属性，返回传递的值</li> <li>在后代组件通过<code>inject</code>接收组件传递过来的值</li></ul> <p>祖先组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">provide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">return</span> <span class="token punctuation">{</span>  
        <span class="token literal-property property">foo</span><span class="token operator">:</span><span class="token string">'foo'</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p>后代组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">inject</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">]</span> <span class="token comment">// 获取到祖先组件传递过来的值 </span>
</code></pre></div><h3 id="请说下封装-vue-组件的过程"><a href="#请说下封装-vue-组件的过程" class="header-anchor">#</a> 请说下封装 vue 组件的过程</h3> <p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。</p> <p>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。</p> <h3 id="vue-js的template编译"><a href="#vue-js的template编译" class="header-anchor">#</a> Vue.js的template编译</h3> <p>简而言之，就是先转化成AST树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），再得到的render函数返回VNode（Vue的虚拟DOM节点，含有标签名、子节点、文本等等），详细步骤如下：</p> <ul><li>将模板<code>template</code>转为<code>ast</code>结构的<code>JS</code>对象</li> <li>用<code>ast</code>得到的<code>JS</code>对象拼装<code>render</code>和<code>staticRenderFns</code>函数</li> <li><code>render</code>和<code>staticRenderFns</code>函数被调用后生成虚拟<code>VNODE</code>节点，该节点包含创建<code>DOM</code>节点所需信息</li> <li><code>vm.patch</code>函数通过虚拟<code>DOM</code>算法利用<code>VNODE</code>节点创建真实<code>DOM</code>节点</li></ul> <h4 id="v-on监听多个方法"><a href="#v-on监听多个方法" class="header-anchor">#</a> v-on监听多个方法</h4> <p>v-on:click = 'add', 语法糖写就是@click = &quot;&quot;，替换成@</p> <p>可以监听多个方法</p> <input type="text"> <h3 id="computed和watch区别"><a href="#computed和watch区别" class="header-anchor">#</a> computed和watch区别</h3> <p>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</p> <p>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</p> <p>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</p> <p>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</p> <p>使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框</p> <p>异步：computed不支持异步，watch支持</p> <h3 id="封装axios"><a href="#封装axios" class="header-anchor">#</a> 封装axios</h3> <p>axios: 基于 <code>XMLHttpRequest</code> 服务来执行 <code>HTTP</code> 请求，支持丰富的配置，支持 <code>Promise</code>，支持浏览器端和 <code>Node.js</code> 端</p> <p>封装目的：随着项目规模增大，如果每发起一次<code>HTTP</code>请求，就要把这些比如设置超时时间、设置请求头、根据项目环境判断使用哪个请求地址、错误处理等等操作，代码将冗余，所以需要二次封装axios</p> <p>需要封装：</p> <p>设置接口请求前缀：根据开发、测试、生产环境的不同，前缀需要加以区分</p> <p>请求头 : 来实现一些具体的业务，必须携带一些参数才可以请求(例如：会员业务)</p> <p>状态码: 根据接口返回的不同<code>status</code> ， 来执行不同的业务，这块需要和后端约定好</p> <p>请求方法：根据<code>get</code>、<code>post</code>等方法进行一个再次封装，使用起来更为方便</p> <p>请求拦截器: 可以在每个请求里加上token，做了统一处理后维护起来也方便</p> <div class="language-js extra-class"><pre class="language-js"><code>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">config</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    config<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'token'</span><span class="token punctuation">]</span> <span class="token operator">=</span> cookie<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> config
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>响应拦截器： 这块就是根据 后端`返回来的状态码判定执行不同业务</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 响应拦截器</span>
axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span>
  <span class="token comment">// 否则的话抛出错误</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>code <span class="token operator">===</span> <span class="token number">511</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 未授权调取授权接口</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>response<span class="token punctuation">.</span>data<span class="token punctuation">.</span>code <span class="token operator">===</span> <span class="token number">510</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 未登录跳转登录页</span>
        router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 我们可以在这里对异常状态作统一处理</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">.</span>response<span class="token punctuation">.</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理请求失败的情况</span>
    <span class="token comment">// 对不同返回码对相应处理</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">.</span>response<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="assets和static的区别"><a href="#assets和static的区别" class="header-anchor">#</a> assets和static的区别</h3> <p>这两个都是用来存放项目中所使用的静态资源文件。</p> <p>两者的区别：</p> <p>assets中的文件在运行npm run build的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到static中。</p> <p>static中的文件则不会被打包。</p> <blockquote><p>建议：将图片等未处理的文件放在assets中，打包减少体积。而对于第三方引入的一些资源文件如iconfont.css等可以放在static中，因为这些文件已经经过处理了。</p></blockquote> <h3 id="slot插槽"><a href="#slot插槽" class="header-anchor">#</a> slot插槽</h3> <p>很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些dom元素，这个时候就可以使用slot插槽了，但是这些dom是否显示以及在哪里显示，则是看子组件中slot组件的位置了。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>parent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>父组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>body<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>我是主体<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>我是其他内容<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>footer<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>我是尾巴<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>child<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>子组件<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>head<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>头部默认值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>body<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>主体默认值<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">&gt;</span></span>这是个匿名插槽(没有name属性)，这串字符是匿名插槽的默认值。<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">&gt;</span></span>
 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>运行结果 ：
父组件
子组件
头部默认值 （具名插槽<code>&lt;slot name=&quot;head&quot;&gt;</code>的默认值被渲染，因为父组件没有为此插槽提供内容）
我是主体 （具名插槽<code>&lt;slot name=&quot;body&quot;&gt;</code>的默认值被覆盖）
我是其他内容 （匿名插槽的默认值被覆盖）</p> <p>注意：</p> <p>1、<code>&lt;p slot=&quot;footer&quot;&gt;我是尾巴&lt;/p&gt;</code> 插槽被丢弃了，因为子组件中没有<code>&lt;slot name=&quot;footer&quot;&gt;</code>的插槽与之匹配。
2、 如果子组件中的匿名插槽不存在，则<code>&lt;p&gt;我是其他内容&lt;/p&gt;</code>也会被丢弃</p> <h3 id="vuex"><a href="#vuex" class="header-anchor">#</a> vuex</h3> <p>一共有5个核心属性，分别是:</p> <ul><li>state 唯一数据源,Vue 实例中的 data 遵循相同的规则</li> <li>getters 可以认为是 store 的计算属性,就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值.</li></ul> <div class="language-php extra-class"><pre class="language-php"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex</span><span class="token operator">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    todos<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token argument-name">text</span><span class="token punctuation">:</span> <span class="token string single-quoted-string">'...'</span><span class="token punctuation">,</span> <span class="token argument-name">done</span><span class="token punctuation">:</span> <span class="token constant boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token argument-name">text</span><span class="token punctuation">:</span> <span class="token string single-quoted-string">'...'</span><span class="token punctuation">,</span> <span class="token argument-name">done</span><span class="token punctuation">:</span> <span class="token constant boolean">false</span> <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token argument-name">getters</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    doneTodos<span class="token punctuation">:</span> state <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token operator">.</span>todos<span class="token operator">.</span><span class="token function">filter</span><span class="token punctuation">(</span>todo <span class="token operator">=&gt;</span> todo<span class="token operator">.</span>done<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

store<span class="token operator">.</span>getters<span class="token operator">.</span>doneTodos <span class="token comment">// -&gt; [{ id: 1, text: '...', done: true }]</span>
</code></pre></div><ul><li>mutation 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation,非常类似于事件,通过store.commit 方法触发</li></ul> <div class="language-php extra-class"><pre class="language-php"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex</span><span class="token operator">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token argument-name">mutations</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 变更状态</span>
      state<span class="token operator">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

store<span class="token operator">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'increment'</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>action Action 类似于 mutation，不同在于Action 提交的是 mutation，而不是直接变更状态，Action 可以包含任意异步操作</li></ul> <div class="language-php extra-class"><pre class="language-php"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex</span><span class="token operator">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token argument-name">mutations</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token operator">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token argument-name">actions</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      context<span class="token operator">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'increment'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>module  由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。</li></ul> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">const moduleA =</span> <span class="token punctuation">{</span>
  <span class="token selector">state: () =&gt; (</span><span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token selector">),
  mutations:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token selector">,
  actions:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token selector">,
  getters:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">const moduleB =</span> <span class="token punctuation">{</span>
  <span class="token selector">state: () =&gt; (</span><span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token selector">),
  mutations:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span><span class="token selector">,
  actions:</span> <span class="token punctuation">{</span> ... <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token selector">const store = new Vuex.Store(</span><span class="token punctuation">{</span>
  <span class="token selector">modules:</span> <span class="token punctuation">{</span>
    <span class="token property">a</span><span class="token punctuation">:</span> moduleA<span class="token punctuation">,</span>
    <span class="token property">b</span><span class="token punctuation">:</span> moduleB
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

store.state.a // -&gt; moduleA 的状态
store.state.b // -&gt; moduleB 的状态
</code></pre></div><p><strong>ajax请求代码应该写在组件的methods中还是vuex的actions中</strong></p> <p>如果请求来的数据是不是要被其他组件公用，仅仅在请求的组件内使用，就不需要放入vuex 的state里。</p> <p>如果被其他地方复用，这个很大几率上是需要的，如果需要，请将请求放入action里，方便复用</p> <h4 id="组件中批量使用vuex的getter属性"><a href="#组件中批量使用vuex的getter属性" class="header-anchor">#</a> 组件中批量使用Vuex的getter属性</h4> <p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>mapGetters<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span><span class="token punctuation">{</span>
    <span class="token literal-property property">computed</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'total'</span><span class="token punctuation">,</span><span class="token string">'discountTotal'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="mutation和action区别"><a href="#mutation和action区别" class="header-anchor">#</a> mutation和action区别</h4> <ul><li>action 提交的是 mutation，而不是直接变更状态。mutation可以直接变更状态</li> <li>action 可以包含任意异步操作。mutation只能是同步操作</li> <li>提交方式不同</li></ul> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code>action 是用<span class="token keyword">this</span><span class="token punctuation">.</span>store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span>'ACTION_NAME'<span class="token punctuation">,</span><span class="token keyword">data</span><span class="token punctuation">)</span>来提交。
mutation是用<span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>'SET_NUMBER'<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>来提交
</code></pre></div><h4 id="在v-model上怎么用vuex中state的值"><a href="#在v-model上怎么用vuex中state的值" class="header-anchor">#</a> 在v-model上怎么用Vuex中state的值？</h4> <p>需要通过computed计算属性来转换。</p> <div class="language-kotlin extra-class"><pre class="language-kotlin"><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string-literal singleline"><span class="token string">&quot;message&quot;</span></span><span class="token operator">&gt;</span>
<span class="token comment">// ...</span>
computed<span class="token operator">:</span> <span class="token punctuation">{</span>
    message<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>message
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">set</span> <span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span>'updateMessage'<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="vue-router"><a href="#vue-router" class="header-anchor">#</a> vue-router</h3> <p>第一步安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm install vue-router -S
</code></pre></div><p>第二步在main.js中使用Vue Router组件</p> <p>第三步配置路由</p> <ul><li>定义 (路由) 组件</li></ul> <p>路由组件可以是直接定义，也可以是导入已经定义好的组件。这里导入已经定义好的组件。</p> <ul><li>定义路由（路由对象数组）</li></ul> <p>定义路由对象数组。对象的path是自定义的路径（即使用这个路径可以找到对应的组件），component是指该路由对应的组件。</p> <ul><li>实例化Vue Router对象</li></ul> <p>调用Vue Router的构造方法创建一个Vue Router的实例对象，将上一步定义的路由对象数组作为参数对象的值传入。</p> <ul><li>挂载根实例</li></ul> <p>第四步在App.vue中使用路由</p> <p>在App.vue中使用标签来显示路由对应的组件，使用标签指定当点击时显示的对应的组件，to属性就是指定组件对应的路由。</p> <h4 id="vue-router的导航钩子"><a href="#vue-router的导航钩子" class="header-anchor">#</a> vue-router的导航钩子</h4> <p>常用的是router.beforeEach(to,from,next)，在跳转前进行权限判断。一共有三种：</p> <ul><li>全局导航钩子：router.beforeEach(to,from,next)</li> <li>组件内的钩子</li> <li>单独路由独享组件</li></ul> <h4 id="vue路由传参"><a href="#vue路由传参" class="header-anchor">#</a> vue路由传参</h4> <blockquote><p>使用query方法传入的参数使用this.$route.query接受</p></blockquote> <blockquote><p>使用params方式传入的参数使用this.$route.params接受</p></blockquote> <h4 id="router和route的区别"><a href="#router和route的区别" class="header-anchor">#</a> router和route的区别</h4> <blockquote><p>route为当前router跳转对象里面可以获取name、path、query、params等</p></blockquote> <blockquote><p>router为VueRouter实例，想要导航到不同URL，则使用router.push方法</p></blockquote> <h4 id="路由按需加载"><a href="#路由按需加载" class="header-anchor">#</a> 路由按需加载</h4> <p>随着项目功能模块的增加，引入的文件数量剧增。如果不做任何处理，那么<strong>首屏加载</strong>会相当的缓慢，这个时候，路由按需加载就闪亮登场了。</p> <div class="language-css extra-class"><pre class="language-css"><code><span class="token selector">webpack&lt; 2.4 时</span>
<span class="token punctuation">{</span> 
    <span class="token property">path</span><span class="token punctuation">:</span><span class="token string">'/'</span><span class="token punctuation">,</span> 
    <span class="token property">name</span><span class="token punctuation">:</span><span class="token string">'home'</span><span class="token punctuation">,</span>
    <span class="token property">components</span><span class="token punctuation">:</span>resolve=&gt;<span class="token function">require</span><span class="token punctuation">(</span>[<span class="token string">'@/components/home'</span>]<span class="token punctuation">,</span>resolve<span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
<span class="token selector">webpack&gt; 2.4 时</span>
<span class="token punctuation">{</span> 
    <span class="token property">path</span><span class="token punctuation">:</span><span class="token string">'/'</span><span class="token punctuation">,</span> 
    <span class="token property">name</span><span class="token punctuation">:</span><span class="token string">'home'</span><span class="token punctuation">,</span> 
    <span class="token property">components</span><span class="token punctuation">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span>=&gt;<span class="token function">import</span><span class="token punctuation">(</span><span class="token string">'@/components/home'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>import()方法是由es6提出的，动态加载返回一个Promise对象，then方法的参数是加载到的模块。类似于Node.js的require方法，主要import()方法是异步加载的。</p> <h4 id="动态路由"><a href="#动态路由" class="header-anchor">#</a> 动态路由</h4> <p>主要场合是权限控制</p> <p><strong>动态路由设置一般有两种</strong>：</p> <p>(1)、简单的角色路由设置：比如只涉及到管理员和普通用户的权限。通常直接在前端进行简单的角色权限设置</p> <p>(2)、复杂的路由权限设置：比如OA系统、多种角色的权限配置。通常需要后端返回路由列表，前端渲染使用</p> <p>动态路由主要通过两个函数实现。<code>router.addRoute()</code> 和 <code>router.removeRoute()</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 添加路由</span>
router<span class="token punctuation">.</span><span class="token function">addRoute</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">'/about'</span><span class="token punctuation">,</span> <span class="token literal-property property">component</span><span class="token operator">:</span> About <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 删除路由</span>
router<span class="token punctuation">.</span><span class="token function">removeRoute</span><span class="token punctuation">(</span><span class="token string">'about'</span><span class="token punctuation">)</span>
</code></pre></div><p>导航守卫：全局守卫router.beforeEach；路由内beforeEnter；组件内beforeRouteEnter</p> <h3 id="生命周期"><a href="#生命周期" class="header-anchor">#</a> 生命周期</h3> <table><thead><tr><th>生命周期</th> <th style="text-align:center;">描述</th></tr></thead> <tbody><tr><td>beforeCreate</td> <td style="text-align:center;">执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr> <tr><td>created</td> <td style="text-align:center;">组件初始化完毕，各种数据可以使用，常用于异步数据获取【数据请求】</td></tr> <tr><td>beforeMount</td> <td style="text-align:center;">未执行渲染、更新，dom未创建</td></tr> <tr><td>mounted</td> <td style="text-align:center;">初始化结束，dom已创建，可用于获取访问数据和dom元素</td></tr> <tr><td>beforeUpdate</td> <td style="text-align:center;">更新前，可用于获取更新前各种状态</td></tr> <tr><td>updated</td> <td style="text-align:center;">更新后，所有状态已是最新</td></tr> <tr><td>beforeDestroy</td> <td style="text-align:center;">销毁前，可用于一些定时器或订阅的取消</td></tr> <tr><td>destroyed</td> <td style="text-align:center;">组件已销毁，作用同上</td></tr></tbody></table> <p>数据请求如果有对页面内容的改动最好放在created声明周期中，如果放在mounted可能导致页面闪动（因为此时页面dom结构已经生成），最好在页面加载前完成请求。</p> <h3 id="v-for和v-if"><a href="#v-for和v-if" class="header-anchor">#</a> v-for和v-if</h3> <p><code>v-for</code>优先级比<code>v-if</code>高</p> <ol><li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li> <li>如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>template v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;isShow&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>p v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">&quot;item in items&quot;</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>
</code></pre></div><ol start="3"><li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">items</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> item<span class="token punctuation">.</span>isShow
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="对象、数组不响应"><a href="#对象、数组不响应" class="header-anchor">#</a> 对象、数组不响应</h3> <p>原因：</p> <p><code>vue2</code>是用过<code>Object.defineProperty</code>实现数据响应式，而新增属性未通过Object.defineProperty设置成响应式</p> <ul><li>如果为对象添加少量的新属性，可以直接采用<code>Vue.set()</code></li> <li>如果需要为新对象添加大量的新属性，则通过<code>Object.assign()</code>创建新对象</li> <li>如果你实在不知道怎么操作时，可采取<code>$forceUpdate()</code>进行强制刷新 (不建议)</li></ul> <p>PS：<code>vue3</code>是用过<code>proxy</code>实现数据响应式的，直接动态添加新属性仍可以实现数据响应式</p> <h3 id="组件和插件"><a href="#组件和插件" class="header-anchor">#</a> 组件和插件</h3> <p>组件 <code>(Component)</code> 是用来构成你的 <code>App</code> 的业务模块，它的目标是 <code>App.vue</code></p> <p>插件 <code>(Plugin)</code> 是用来增强你的技术栈的功能模块，它的目标是 <code>Vue</code> 本身</p> <p>简单来说，插件就是指对<code>Vue</code>的功能的增强或补充</p> <h4 id="组件注册"><a href="#组件注册" class="header-anchor">#</a> 组件注册</h4> <p><code>vue</code>组件注册主要分为全局注册与局部注册</p> <p>全局注册通过<code>Vue.component</code>方法，第一个参数为组件的名称，第二个参数为传入的配置项</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'my-component-name'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>局部注册只需在用到的地方通过<code>components</code>属性注册一个组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> component1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span> <span class="token comment">// 定义一个组件</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">components</span><span class="token operator">:</span><span class="token punctuation">{</span>
		component1   <span class="token comment">// 局部注册</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="插件注册"><a href="#插件注册" class="header-anchor">#</a> 插件注册</h4> <p>插件的注册通过<code>Vue.use()</code>的方式进行注册（安装），第一个参数为插件的名字，第二个参数是可选择的配置项</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>插件名字<span class="token punctuation">,</span><span class="token punctuation">{</span> <span class="token comment">/* ... */</span><span class="token punctuation">}</span> <span class="token punctuation">)</span>
</code></pre></div><h3 id="nexttick"><a href="#nexttick" class="header-anchor">#</a> $nextTick</h3> <p><code>Vue</code> 在更新 <code>DOM</code> 时是<strong>异步</strong>执行的。当数据发生变化，<code>Vue</code>将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新</p> <p><strong>使用场景</strong>：</p> <p>修改数据后立刻得到更新后的<code>DOM</code>结构，可以使用<code>this.nextTick()</code></p> <h3 id="keep-alive-缓存组件"><a href="#keep-alive-缓存组件" class="header-anchor">#</a> keep-alive--缓存组件</h3> <p><code>keep-alive</code>是<code>vue</code>中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染<code>DOM</code></p> <p><code>keep-alive</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>component <span class="token punctuation">:</span>is<span class="token operator">=</span><span class="token string">&quot;view&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>component<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
</code></pre></div><p>在路由中设置<code>keepAlive</code>属性判断是否需要缓存</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token punctuation">{</span>
  path<span class="token punctuation">:</span> <span class="token char">'list'</span><span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token char">'itemList'</span><span class="token punctuation">,</span> <span class="token comment">// 列表页</span>
  component <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span>'@<span class="token operator">/</span>pages<span class="token operator">/</span>item<span class="token operator">/</span>list'<span class="token punctuation">]</span><span class="token punctuation">,</span> resolve<span class="token punctuation">)</span>
 <span class="token punctuation">}</span><span class="token punctuation">,</span>
 meta<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  keepAlive<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  title<span class="token punctuation">:</span> <span class="token char">'列表页'</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用<code>&lt;keep-alive&gt;</code></p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">&quot;app&quot;</span> class<span class="token operator">=</span><span class="token char">'wrapper'</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 需要缓存的视图组件 <span class="token operator">--</span><span class="token operator">&gt;</span> 
        <span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span><span class="token operator">/</span>keep<span class="token operator">-</span>alive<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 不需要缓存的视图组件 <span class="token operator">--</span><span class="token operator">&gt;</span>
     <span class="token operator">&lt;</span>router<span class="token operator">-</span>view v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">&quot;!$route.meta.keepAlive&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>router<span class="token operator">-</span>view<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><h3 id="修饰符"><a href="#修饰符" class="header-anchor">#</a> 修饰符</h3> <ul><li>.stop：阻止事件冒泡</li> <li>.native：绑定原生事件</li> <li>.once：事件只执行一次</li> <li>.self ：将事件绑定在自身身上，相当于阻止事件冒泡</li> <li>.prevent：阻止默认事件</li> <li>.caption：用于事件捕获</li> <li>.once：只触发一次</li> <li>.keyCode：监听特定键盘按下</li> <li>.right：右键</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div @click<span class="token operator">=</span><span class="token string">&quot;shout(2)&quot;</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>button @click<span class="token punctuation">.</span>stop<span class="token operator">=</span><span class="token string">&quot;shout(1)&quot;</span><span class="token operator">&gt;</span>ok<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token comment">//只输出1</span>
</code></pre></div><h3 id="mixin"><a href="#mixin" class="header-anchor">#</a> mixin</h3> <p>用于封装可复用的功能</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> toggle <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">isShowing</span><span class="token operator">:</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">toggleShow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>isShowing <span class="token operator">=</span> <span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>isShowing<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Modal <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'#modal'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>toggle<span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token keyword">const</span> Tooltip <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">template</span><span class="token operator">:</span> <span class="token string">'#tooltip'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>toggle<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vue和react对比" class="sidebar-link reco-side-vue和react对比" data-v-b57cc07c>VUE和REACT对比</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#指令系统" class="sidebar-link reco-side-指令系统" data-v-b57cc07c>指令系统</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#spa" class="sidebar-link reco-side-spa" data-v-b57cc07c>SPA</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#虚拟dom" class="sidebar-link reco-side-虚拟dom" data-v-b57cc07c>虚拟dom</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#diff算法" class="sidebar-link reco-side-diff算法" data-v-b57cc07c>diff算法</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vue2和vue3区别" class="sidebar-link reco-side-vue2和vue3区别" data-v-b57cc07c>Vue2和Vue3区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#绑定数据" class="sidebar-link reco-side-绑定数据" data-v-b57cc07c>绑定数据</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#为什么data必须是函数" class="sidebar-link reco-side-为什么data必须是函数" data-v-b57cc07c>为什么data必须是函数</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vue-loader" class="sidebar-link reco-side-vue-loader" data-v-b57cc07c>vue-loader</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#v-for中key作用" class="sidebar-link reco-side-v-for中key作用" data-v-b57cc07c>v-for中key作用</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vue的双向数据绑定原理是什么" class="sidebar-link reco-side-vue的双向数据绑定原理是什么" data-v-b57cc07c>Vue的双向数据绑定原理是什么？</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#组件通信" class="sidebar-link reco-side-组件通信" data-v-b57cc07c>组件通信</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#请说下封装-vue-组件的过程" class="sidebar-link reco-side-请说下封装-vue-组件的过程" data-v-b57cc07c>请说下封装 vue 组件的过程</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vue-js的template编译" class="sidebar-link reco-side-vue-js的template编译" data-v-b57cc07c>Vue.js的template编译</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#computed和watch区别" class="sidebar-link reco-side-computed和watch区别" data-v-b57cc07c>computed和watch区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#封装axios" class="sidebar-link reco-side-封装axios" data-v-b57cc07c>封装axios</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#assets和static的区别" class="sidebar-link reco-side-assets和static的区别" data-v-b57cc07c>assets和static的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#slot插槽" class="sidebar-link reco-side-slot插槽" data-v-b57cc07c>slot插槽</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vuex" class="sidebar-link reco-side-vuex" data-v-b57cc07c>vuex</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#vue-router" class="sidebar-link reco-side-vue-router" data-v-b57cc07c>vue-router</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#生命周期" class="sidebar-link reco-side-生命周期" data-v-b57cc07c>生命周期</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#v-for和v-if" class="sidebar-link reco-side-v-for和v-if" data-v-b57cc07c>v-for和v-if</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#对象、数组不响应" class="sidebar-link reco-side-对象、数组不响应" data-v-b57cc07c>对象、数组不响应</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#组件和插件" class="sidebar-link reco-side-组件和插件" data-v-b57cc07c>组件和插件</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#nexttick" class="sidebar-link reco-side-nexttick" data-v-b57cc07c>$nextTick</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#keep-alive-缓存组件" class="sidebar-link reco-side-keep-alive-缓存组件" data-v-b57cc07c>keep-alive--缓存组件</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#修饰符" class="sidebar-link reco-side-修饰符" data-v-b57cc07c>修饰符</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/vue.html#mixin" class="sidebar-link reco-side-mixin" data-v-b57cc07c>mixin</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/9blog/assets/js/app.3e8fe7ca.js" defer></script><script src="/9blog/assets/js/3.4ae95a2d.js" defer></script><script src="/9blog/assets/js/1.ac641155.js" defer></script><script src="/9blog/assets/js/28.45a89b98.js" defer></script>
  </body>
</html>
