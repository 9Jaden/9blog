<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你必须掌握的前端基础知识🔥 | 嘉梁的博客</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/9blog/icon.jpg">
    <meta name="description" content="Welcome!">
    
    <link rel="preload" href="/9blog/assets/css/0.styles.e39160fb.css" as="style"><link rel="preload" href="/9blog/assets/js/app.3e8fe7ca.js" as="script"><link rel="preload" href="/9blog/assets/js/3.4ae95a2d.js" as="script"><link rel="preload" href="/9blog/assets/js/1.ac641155.js" as="script"><link rel="preload" href="/9blog/assets/js/30.768ec0c1.js" as="script"><link rel="prefetch" href="/9blog/assets/js/10.f32e5926.js"><link rel="prefetch" href="/9blog/assets/js/11.a32291ec.js"><link rel="prefetch" href="/9blog/assets/js/12.854853e6.js"><link rel="prefetch" href="/9blog/assets/js/13.d58b78e1.js"><link rel="prefetch" href="/9blog/assets/js/14.b74e23f1.js"><link rel="prefetch" href="/9blog/assets/js/15.36f6770d.js"><link rel="prefetch" href="/9blog/assets/js/16.542bf7be.js"><link rel="prefetch" href="/9blog/assets/js/17.e1b738e9.js"><link rel="prefetch" href="/9blog/assets/js/18.f00a61c5.js"><link rel="prefetch" href="/9blog/assets/js/19.dddc4cb9.js"><link rel="prefetch" href="/9blog/assets/js/20.895aaf01.js"><link rel="prefetch" href="/9blog/assets/js/21.b6755c35.js"><link rel="prefetch" href="/9blog/assets/js/22.38b1460c.js"><link rel="prefetch" href="/9blog/assets/js/23.21ba7001.js"><link rel="prefetch" href="/9blog/assets/js/24.38298f63.js"><link rel="prefetch" href="/9blog/assets/js/25.0834d742.js"><link rel="prefetch" href="/9blog/assets/js/26.f7a3dd00.js"><link rel="prefetch" href="/9blog/assets/js/27.b3d77e32.js"><link rel="prefetch" href="/9blog/assets/js/28.45a89b98.js"><link rel="prefetch" href="/9blog/assets/js/29.b75831cb.js"><link rel="prefetch" href="/9blog/assets/js/31.c8818d1b.js"><link rel="prefetch" href="/9blog/assets/js/32.a8e266aa.js"><link rel="prefetch" href="/9blog/assets/js/33.b2484fc9.js"><link rel="prefetch" href="/9blog/assets/js/34.347bdff3.js"><link rel="prefetch" href="/9blog/assets/js/35.42bd7061.js"><link rel="prefetch" href="/9blog/assets/js/4.153cb639.js"><link rel="prefetch" href="/9blog/assets/js/5.aa9edc01.js"><link rel="prefetch" href="/9blog/assets/js/6.d146555e.js"><link rel="prefetch" href="/9blog/assets/js/7.80cabe8f.js"><link rel="prefetch" href="/9blog/assets/js/8.9c58261e.js"><link rel="prefetch" href="/9blog/assets/js/9.f9ada005.js">
    <link rel="stylesheet" href="/9blog/assets/css/0.styles.e39160fb.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>嘉梁的博客</h3> <p class="description" data-v-59e6cb88>Welcome!</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>JIALIANG</span>
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/9blog/" class="home-link router-link-active"><img src="/9blog/avatar.jpg" alt="嘉梁的博客" class="logo"> <span class="site-name">嘉梁的博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/9blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/9blog/categories/前端学习笔记/" class="nav-link"><i class="undefined"></i>
  前端学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/9blog/categories/项目简介/" class="nav-link"><i class="undefined"></i>
  项目简介
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      About嘉梁
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://weibo.com/u/5532906301" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  个人微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/9blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><img src="/9blog/avatar.jpg" alt="author-avatar" class="personal-img" data-v-1fad0c41> <h3 class="name" data-v-1fad0c41>
    JIALIANG
  </h3> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>25</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>49</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/9blog/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      博客
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/9blog/categories/前端学习笔记/" class="nav-link"><i class="undefined"></i>
  前端学习笔记
</a></li><li class="dropdown-item"><!----> <a href="/9blog/categories/项目简介/" class="nav-link"><i class="undefined"></i>
  项目简介
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      About嘉梁
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://weibo.com/u/5532906301" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  个人微博
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div><div class="nav-item"><a href="/9blog/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  Tag
</a></div> <!----></nav> <!----> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>你必须掌握的前端基础知识🔥</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><span data-v-59e6cb88>JIALIANG</span>
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">你必须掌握的前端基础知识🔥</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>JIALIANG</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>2/2/2023</span></i> <!----> <i class="tags iconfont reco-tag" data-v-8a445198><span class="tag-item" data-v-8a445198>前端</span></i></div></div> <div class="theme-reco-content content__default"><h2 id="_1-原型链和原型对象"><a href="#_1-原型链和原型对象" class="header-anchor">#</a> 1. 原型链和原型对象</h2> <h3 id="引用类型"><a href="#引用类型" class="header-anchor">#</a> 引用类型</h3> <p><strong>Object, Array, Function</strong>, Date, RegExp</p> <h4 id="引用类型四个规则"><a href="#引用类型四个规则" class="header-anchor">#</a> 引用类型四个规则：</h4> <blockquote><p>1、引用类型，都具有对象特性，即可自由扩展属性。</p> <p>2、引用类型，都有一个隐式原型 <code>__proto__</code> 属性，属性值是一个普通的对象。</p> <p>3、引用类型，隐式原型 <code>__proto__</code> 的属性值指向它的构造函数的显式原型 <code>prototype</code> 属性值。</p> <div class="language- extra-class"><pre class="language-text"><code>obj.__proto__ == Object.prototype // true
arr.__proto__ === Array.prototype // true
fn.__proto__ == Function.prototype // true
</code></pre></div><p>4、当你试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么它会去它的隐式原型 <code>__proto__</code>（也就是它的构造函数的显式原型 <code>prototype</code>）中寻找</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token comment">// 其实这行可以不写，默认返回 this 对象</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> nick <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&quot;nick&quot;</span><span class="token punctuation">)</span>
nick<span class="token punctuation">.</span>toString
<span class="token comment">// ƒ toString() { [native code] }</span>
</code></pre></div><p><code>nick</code> 实例先从自身出发检讨自己，发现并没有 <code>toString</code> 方法。找不到，就往上走，找 <code>Person</code> 构造函数的 <code>prototype</code> 属性，还是没找到。构造函数的 <code>prototype</code> 也是一个对象嘛，那对象的构造函数是 <code>Object</code> ，所以就找到了 <code>Object.prototype</code> 下的 <code>toString</code> 方法</p> <p><strong>JavaScript 里万物皆对象</strong></p> <p>最后一个 <code>null</code>，设计上是为了避免死循环而设置的, <code>Object.prototype</code> 的隐式原型指向 <code>null</code></p> <p>原型链好比继承+迭代，他可以让一个对象，继承多种多样的属性，方法。
而__proto__和prototype，就好比人的dna。__proto__指向父母，prototype代表父母自己。
两者的区别就在于此。</p> <p>proto是指针，prototype是主体</p> <h2 id="_2-基本数据类型"><a href="#_2-基本数据类型" class="header-anchor">#</a> 2. 基本数据类型</h2> <p>Number, Boolean, String, Symbol, <strong>Null, Undefined</strong></p> <h3 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h3> <p>ES6 引入的一种新的原始数据类型Symbol，表示独一无二的值</p> <p>symbol 类型的值可以作为对象的属性<a href="https://so.csdn.net/so/search?q=%E6%A0%87%E8%AF%86%E7%AC%A6&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">标识符<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>使用，这也是 symbol 类型设计的目的</p> <p>所以现在对象属性名可以为两种类型：一种就是原本的字符串类型，一种即为新增的 symbol 类型。凡是使用 symbol 命名的属性都是独一无二的，保证不与其他属性名产生冲突</p> <p>Symbol(str)传入字符串进行类型转换</p> <p>Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型</p> <p>Symbol 值可以显式（toString()）转为字符串,Symbol 值也可以转为布尔值(Boolean())，但是不能转为数值</p> <h3 id="引用数据类型和基本数据类型区别"><a href="#引用数据类型和基本数据类型区别" class="header-anchor">#</a> 引用数据类型和基本数据类型区别</h3> <p>最主要是存储方式：引用数据类型存储在变量处的值是一个指针，指向存储对象的内存地址，而基本数据类型的值直接存储在变量访问的位置</p> <p>复制变量时不同：对于原始值两个变量完全独立只是值相同；而对于引用值是多了一个指针，指向堆内存中同一个对象，任何一个副本做出的改变都会反映在另一个身上。</p> <h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="header-anchor">#</a> 深拷贝和浅拷贝</h3> <p>这两者都是对于引用数据类型而言的</p> <p>浅复制指针，所以新旧对象共享内存；Object.assign({}, person)</p> <p>深会创造一个一模一样的对象，不共享内存且修改新对象不影响原对象; JSON.stringify后JSON.parse</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> copy_data <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>origin_data<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>纯手写</p> <div class="language-js extra-class"><pre class="language-js"><code>		<span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//查看要拷贝的对象是数组还是对象，如果数组创建空数组，是对象创建空对象</span>
            <span class="token keyword">let</span> newObj <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//K属性名  obj[k]值</span>
                <span class="token comment">//判断当前每个元素是否是对象或者数组 </span>
                <span class="token comment">//如果还是对象，继续递归拷贝</span>
                <span class="token comment">//是值，直接添加到新创建的对象或者数组里</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">//递归拷贝完 放入到新对象的属性</span>
                    newObj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">//否则是值， 直接添加到新建的 newObj中</span>
                    newObj<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>k<span class="token punctuation">]</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//返回新对象</span>
            <span class="token keyword">return</span> newObj
        <span class="token punctuation">}</span>
</code></pre></div><h2 id="_3-闭包"><a href="#_3-闭包" class="header-anchor">#</a> 3. 闭包</h2> <p><strong>函数嵌套函数，且内部函数调用父级作用域的变量就可以称之为闭包</strong></p> <p>当一个函数返回函数时，闭包就变得十分重要，返回的函数可以访问不属于全局作用域的变量，它们仅存在于闭包中</p> <p><strong>无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。闭包包含在函数创建时作用域中的所有变量，它类似于背包。函数定义附带一个小背包，它的包中存储了函数定义创建时作用域中的所有变量</strong></p> <p>虽然函数return后删除函数的本地执行上下文，其内含变量和函数定义等都不复存在，但是如果函数定义被返回，其内会包含存储函数作用域中所有变量的闭包，闭包一同跟着函数定义被返回，但是闭包中的变量不属于全局作用域，仅存在于闭包中，仅该函数定义确定的函数<code>const increment = createCounter()</code>可以访问</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">const</span> <span class="token function-variable function">myFunction</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     counter <span class="token operator">=</span> counter <span class="token operator">+</span> <span class="token number">1</span>
     <span class="token keyword">return</span> counter
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> myFunction
 <span class="token punctuation">}</span>
 <span class="token keyword">const</span> increment <span class="token operator">=</span> <span class="token function">createCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token keyword">const</span> c1 <span class="token operator">=</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token keyword">const</span> c2 <span class="token operator">=</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 <span class="token keyword">const</span> c3 <span class="token operator">=</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
 console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'example increment'</span><span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> c3<span class="token punctuation">)</span> <span class="token comment">// 1, 2, 3而不是1, 1, 1</span>
</code></pre></div><p>也可以说是上级作用域内变量的生命周期，因为被下级作用域内引用，而没有被释放</p> <p>上面的例子中myFunction的上级作用域中的counter因为被引用了所以没有被释放而保存在闭包中被一同返回</p> <p><strong>永远记住闭包的方法是通过背包的类比。当一个函数被创建并传递或从另一个函数返回时，它会携带一个背包。背包中是函数声明时作用域内的所有变量。</strong></p> <p><strong>滥用闭包会导致内存泄漏</strong></p> <p>因为它把外部的包含它的函数的活动对象也包含在自己的作用域链中了（函数执行上下文中的所有变量也需要保存在内存，不会被回收），一旦循环引用或创建闭包，就会占据大量内存，可能会引起内存泄漏</p> <h2 id="_4-var-let-const"><a href="#_4-var-let-const" class="header-anchor">#</a> 4. var let const</h2> <h3 id="var-变量提升、可多次声明同一变量"><a href="#var-变量提升、可多次声明同一变量" class="header-anchor">#</a> var---变量提升、可多次声明同一变量</h3> <p>在全局作用域还是在局部作用域中，使用var关键字声明的变量都会被提升到该作用域最顶部</p> <p>在函数内var变量时该变量局域</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token string">&quot;蛙人&quot;</span> 
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token punctuation">}</span>
<span class="token function">person</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><p>因为var变量提升，等价于下面的代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> value<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token string">&quot;蛙人&quot;</span> 
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token punctuation">}</span>
<span class="token function">person</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="let-块级声明、禁止重复声明"><a href="#let-块级声明、禁止重复声明" class="header-anchor">#</a> let---块级声明、禁止重复声明</h3> <blockquote><p>ES6提出块级声明：只在<strong>当前函数下</strong>声明的变量有效；在<strong>代码块和{}括号</strong>之内有效</p></blockquote> <p>没有变量提升</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">person</span><span class="token punctuation">(</span><span class="token parameter">status</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">&quot;蛙人&quot;</span> 
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
<span class="token punctuation">}</span>
<span class="token function">person</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="暂时性死区"><a href="#暂时性死区" class="header-anchor">#</a> 暂时性死区</h3> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment">// 报错</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">&quot;蛙人&quot;</span>
<span class="token comment">// 以上称作描述const和let不会变量提升的暂时性死区(TDZ, temporal dead zone)，仅当前作用域内有效（所以下面例子不会报错）</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> value<span class="token punctuation">)</span>  <span class="token comment">// &quot;undefined&quot;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">&quot;蛙人&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>直到真正执行let或const赋值语句时，该变量都不可使用</p> <h3 id="const-常量、必须初始化、块级作用域"><a href="#const-常量、必须初始化、块级作用域" class="header-anchor">#</a> const---常量、必须初始化、块级作用域</h3> <p>与let同样不能在当前作用域重复声明，没有变量提升，同样是块级作用域</p> <blockquote><p>const变量<strong>不能修改指针</strong>，但是可以修改值，比如const一个变量可以修改它属性值，但是不能直接重写整个对象，如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;蛙人&quot;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">23</span>
<span class="token punctuation">}</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span> <span class="token comment">// 没问题</span>
person <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 报错 不能修改对象指针</span>
</code></pre></div><p>对于简单类型数据，值就保存在变量指向的内存地址，不可改变，等同于常量；</p> <p>对于复杂类型数据，变量保存的是指向实际数据的指针</p></blockquote> <h3 id="var相比let-const最大区别"><a href="#var相比let-const最大区别" class="header-anchor">#</a> var相比let const最大区别</h3> <p>var在全局作用域声明的变量会创建一个新的全局变量挂载在window上，作为全局对象的属性，而let const不会有</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> value1 <span class="token operator">=</span> <span class="token string">&quot;张三&quot;</span>
<span class="token keyword">let</span> value2 <span class="token operator">=</span> <span class="token string">&quot;李四&quot;</span>
<span class="token keyword">const</span> value3 <span class="token operator">=</span> <span class="token string">&quot;王五&quot;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>value1<span class="token punctuation">)</span> <span class="token comment">// 张三</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>value2<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>value3<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre></div><h3 id="主要围绕以下五点"><a href="#主要围绕以下五点" class="header-anchor">#</a> 主要围绕以下五点</h3> <blockquote><ol><li>变量提升</li> <li>暂时性死区</li> <li>块级作用域</li> <li>重复声明</li> <li>修改声明的变量</li> <li>使用：能用const尽量用const，然后let，避免用var</li></ol></blockquote> <h2 id="_5-localstorage、sessionstorage-cookie、session区别"><a href="#_5-localstorage、sessionstorage-cookie、session区别" class="header-anchor">#</a> 5. localStorage、sessionStorage||cookie、session区别</h2> <h3 id="cookie和session区别"><a href="#cookie和session区别" class="header-anchor">#</a> cookie和session区别</h3> <blockquote><p>cookie数据存放在客户端，session存放在服务器端</p> <p>cookie并不安全（跨站请求伪造CSRF），session会影响服务器性能</p> <p>cookie存储容量小，数据无法持续化存储</p></blockquote> <h3 id="cookie、localstorage和sessionstorage"><a href="#cookie、localstorage和sessionstorage" class="header-anchor">#</a> cookie、localStorage和sessionStorage</h3> <p>要点：生命、位置、大小、携带</p> <blockquote><p><strong>生命周期(写入设置or永久有效or关闭浏览器)</strong></p> <p><strong>存储位置都为客户端（浏览器本地存储）</strong></p> <p><strong>cookie容量小(4KB vs 5M)</strong></p> <p><strong>请求时cookie自动携带</strong>---所以也会造成CSRF问题</p></blockquote> <p>常用场景：</p> <blockquote><p>cookie一般存储登录验证消息|token</p> <p>localStorage存储不易变动数据，减轻服务器压力</p> <p>sessionStorage监测用户是否刷新进入页面，如音乐播放器恢复进度条功能</p></blockquote> <table><thead><tr><th>分类</th> <th>生命周期</th> <th>存储容量</th> <th>存储位置</th></tr></thead> <tbody><tr><td>cookie</td> <td>默认保存在内存中，随浏览器关闭失效（如果设置过期时间，在到过期时间后失效）</td> <td>4KB</td> <td>保存在客户端，每次请求时都会带上</td></tr> <tr><td>localStorage</td> <td>理论上永久有效的，除非主动清除。</td> <td>4.98MB（不同浏览器情况不同，safari 2.49M）</td> <td>保存在客户端，不与服务端交互。节省网络流量</td></tr> <tr><td>sessionStorage</td> <td>仅在当前网页会话下有效，关闭页面或浏览器后会被清除。</td> <td>4.98MB（部分浏览器没有限制）</td> <td>同上</td></tr></tbody></table> <h3 id="如何实现可过期的localstorage"><a href="#如何实现可过期的localstorage" class="header-anchor">#</a> 如何实现可过期的localStorage</h3> <p><strong>惰性删除</strong>：惰性删除是指获取数据的时候，拿到存储的时间和当前时间做对比，如果超过过期时间就清除Cookie。</p> <p>某个键值过期后，该键值不会被马上删除，而是等到下次被使用的时候，才会被检查到过期，此时才能得到删除</p> <p><strong>定时删除</strong>：每隔一段时间执行一次删除操作，并通过限制删除操作执行的次数和频率，来减少删除操作对CPU的长期占用。</p> <p>LocalStorage清空应用场景：token存储在LocalStorage中，要清空</p> <h4 id="浏览器垃圾回收机制-标记-引用"><a href="#浏览器垃圾回收机制-标记-引用" class="header-anchor">#</a> 浏览器垃圾回收机制--标记|引用</h4> <p>1、标记清除：对所有活动对象进行标记，清除阶段会<strong>将没有标记的对象清除</strong>；标记整理算法：标记结束后，算法将活动对象压入内存一端，则需要清理的对象在边界，直接被清理掉就行。（效率低）</p> <p>2、引用计数：将对象是否不再需要简化定义为<strong>有没有其他对象引用它</strong>，如果没有引用指向这个对象，则会被垃圾回收机制回收。（内存空间不连续）</p> <h2 id="_6-谈谈es6理解-新增属性"><a href="#_6-谈谈es6理解-新增属性" class="header-anchor">#</a> 6. 谈谈ES6理解，新增属性？</h2> <p><strong>es6 是一个新的标准，它包含了许多新的语言特性和库，是 JS 最实质性的一次升级。</strong></p> <p>比如’<strong>箭头函数</strong>’、’字符串模板’、’generators(生成器)’、<strong>异步编程解决方法</strong>’promise, async/await’、’<strong>解构赋值</strong>’、’class’等等，还有就是引入 module 模块的概念</p> <h2 id="_7-箭头函数和普通函数区别-围绕this、构造函数"><a href="#_7-箭头函数和普通函数区别-围绕this、构造函数" class="header-anchor">#</a> 7. 箭头函数和普通函数区别（围绕this、构造函数）</h2> <blockquote><ol><li>箭头更加简洁</li> <li>箭头函数没有prototype，<strong>本身</strong>没有this</li> <li>所以箭头函数的this继承外层执行环境的this，this固定化</li> <li>箭头函数不能作为构造函数使用</li></ol> <div class="language- extra-class"><pre class="language-text"><code>构造函数new过程 ① JS内部首先会先生成一个对象； ② 再把函数中的this指向该对象； ③ 然后执行构造函数中的语句； ④ 最终返回该对象实例
而箭头函数没有自己的this所以不行
</code></pre></div><p>call|apply|bind无法改变箭头函数this指向</p> <p>没有自己的arguments对象，也是继承外层的，取而代之用=(...a)=&gt;{}</p></blockquote> <h2 id="_8-谈谈对promise的理解-异步-地狱、容器、三态、单向"><a href="#_8-谈谈对promise的理解-异步-地狱、容器、三态、单向" class="header-anchor">#</a> 8. 谈谈对promise的理解（异步-地狱、容器、三态、单向）</h2> <p>异步编程的解决方案，解决回调地狱问题</p> <p>将promise看作容器，里面装着未来才会执行完毕事件的结果，且结果一旦生成无法改变</p> <p>promise对象代表一个异步操作，有三种状态pending（进行中）、resolved、rejected</p> <p>一旦状态改变则不会再变，<strong>单向</strong></p> <h2 id="_9-promise与async-await区别"><a href="#_9-promise与async-await区别" class="header-anchor">#</a> 9. promise与async/await区别</h2> <blockquote><p>async/await让异步代码看起来像同步代码，更加简洁（promise回调链复杂场景不美观）</p> <p>两者都是非阻塞（得到结果之前不会阻塞线程）</p> <p>async/await基于promise实现</p></blockquote> <h2 id="_10-promise如何解决回调地狱问题"><a href="#_10-promise如何解决回调地狱问题" class="header-anchor">#</a> 10. promise如何解决回调地狱问题</h2> <h3 id="回调地狱"><a href="#回调地狱" class="header-anchor">#</a> 回调地狱</h3> <p>回调函数里嵌套回调函数，当异步返回值又需要等待另一个异步就会嵌套回调</p> <p>回调地狱两个主要问题：</p> <ol><li>多层嵌套的问题；<strong>（Promise通过then延迟绑定回调函数，并且then方法同样返回一个Promise对象，这样将多层嵌套---&gt;链式调用，更符合人线性思维模式）</strong></li> <li>每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性。<strong>（Promise可以错误冒泡，前面产生错误可以被后面catch接受，减少频繁判断错误的混乱性）</strong></li></ol> <p>解决原理就是<strong>将参数和回调进行分离</strong></p> <p>待定状态的 Promise 对象执行的话，最后要么会通过一个值完成，要么会通过一个原因被拒绝。当其中一种情况发生时，我们用 Promise 的 then 方法排列起来的相关处理程序就会被调用。因为最后 Promise.prototype.then 和 Promise.prototype.catch 方法返回的是一个 Promise， 所以它们可以继续被链式调用</p> <p>三大技术手段来解决回调地狱：回调函数延迟绑定、返回值穿透、错误冒泡</p> <blockquote><p>Promise的回调函数不是直接声明的而是通过then方法传入</p> <p>前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了</p></blockquote> <p>Promise实现链式调用，解决多层嵌套问题；实现错误冒泡后一站式处理，解决每次任务中判断错误、增加代码混乱度的问题</p> <h2 id="_11-promise详解"><a href="#_11-promise详解" class="header-anchor">#</a> 11. promise详解</h2> <ol><li>Promise对象是一个<strong>构造函数</strong>，接受两个参数resolve和reject</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>resolve函数将promise对象的状态从pending改为fulfilled</p> <p>reject函数将promise对象的状态从pending改为rejected</p> <ol start="2"><li><p>Promise构造出来的实例对象存在方法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>promise
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>···<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>初始化Promise时，执行器函数已经改变了Promise的状态。且执行器函数是同步执行的。异步操作返回的数据（成功的值和失败的原因）可以交给.then处理，为Promise实例提供处理程序</strong></p></li></ol> <blockquote><p><strong>then()-</strong>--实例状态发生改变时的回调函数，两个参数，一个是resolved成功时回调函数，另一个是rejected失败时回调函数</p> <p>​	<strong>then方法返回的也是一个新的promise实例</strong>，所以Promise可以<strong>链式调用</strong></p> <p><strong>catch()</strong>---指定发生错误时的回调函数</p> <p>​	一般使用catch方法代替then()的第二个参数</p> <p>finally()---指定不管promise对象最后状态如何都会执行的操作</p></blockquote> <ol start="3"><li>Promise构造函数方法---也就是Promise的方法</li></ol> <blockquote><p>all()---将多个Promise实例包装成一个新的Promise实例</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>race()---同样是包装多个为一个</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>resolve()---将现有对象转为Promise对象</p> <p>rejecte()---也会返回一个新的Promise实例，但状态为rejected</p> <p>allSettled()---同样接受一组Promise实例作为参数包装得新Promise实例，它会等到所有参数实例都返回结果才结束</p></blockquote> <h3 id="解构promise对象-实质构造函数"><a href="#解构promise对象-实质构造函数" class="header-anchor">#</a> 解构Promise对象---实质构造函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Promise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'pending'</span>  <span class="token comment">// 初始化 未完成状态 </span>
        <span class="token comment">// 成功的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
        <span class="token comment">// 失败的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>

        <span class="token comment">// .then 立即执行后 state为pengding  把.then保存起来</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

        <span class="token comment">// 把异步任务 把结果交给 resolve</span>
        <span class="token keyword">let</span> <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fulfilled 状态被执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
                <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'fulfilled'</span>
                <span class="token comment">// onFulfilled 要执行一次</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">let</span> <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'rejected 状态被执行'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason
                <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token string">'rejected'</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">fn</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 一个promise解决了后（完成状态转移，把控制权交出来）</span>
    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">'pending'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>onResolvedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>onRejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 状态为fulfilled  执行成功  传入成功后的回调  把执行权转移</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">'fulfilled'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">onFulfilled</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 状态为rejected 执行失败  传入失败后的回调  把执行权转移</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">==</span> <span class="token string">'rejected'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">onRejected</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>      
        <span class="token comment">// resolve(10)</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'JS我不爱你了'</span><span class="token punctuation">)</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">'++++++++++'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token number">0</span>
then
rejected 状态被执行
<span class="token constant">JS</span>我不爱你了 <span class="token operator">++</span><span class="token operator">++</span><span class="token operator">++</span><span class="token operator">++</span><span class="token operator">++</span>
setTimeout
</code></pre></div><p>上述代码未实现链式调用，then未返回Promise实例</p> <h3 id="promise方法中all-和race-的区别"><a href="#promise方法中all-和race-的区别" class="header-anchor">#</a> Promise方法中all()和race()的区别</h3> <blockquote><p>all()需要所有Promise实例对象都变成fulfilled，包装后Promise实例才会fulfilled，且合成Promise返回所有子Promise的返回值数组；</p> <p>all()一旦有一个被rejected，包装后的也reject，第一个失败的子Promise的reason作为合成Promise的失败reason</p> <p>而race()只要有一个实例率先改变状态，包装后的Promise实例跟着它改变，谁先就以谁作为回调</p></blockquote> <p>race可用于设置图片请求超时（race图片资源请求和请求计时）</p> <p>注意all和race都是返回一个promise对象</p> <p>return new Promise((resolve, reject) =&gt; {</p> <p>​	 if (...) { reject(new Error(''))}</p> <p>​	if (...) {resolve(data)} // 对于all来说data为所有resolve的值的数组</p> <p>})</p> <p><strong>all</strong>：遍历promiseArray然后Promise.resolve(promiseArray[i]).then(value=&gt;data.push(value)</p> <p>//利用count判断是否达到数组长度所有都resolve了后再resolve(data)，resolve合成的data</p> <p>).catch(e=&gt;reject(e))</p> <p><strong>race</strong>: 返回return new Promise(function(resolve, reject) {</p> <p>// 在其中try和catch看有无resolved的promise</p> <p>try{</p> <p>promiseArray.forEach(p=&gt;{</p> <p>// 前提是有promise成功了所以直接then</p> <p>p.then(data=&gt;{</p> <p>// 并且是第一个resolve的</p> <p>if (!resolved) {</p> <p>resolved = false;</p> <p>resolve(data)</p> <p>}</p> <p>})</p> <p>})</p> <p>}catch(error){</p> <p>reject(error)</p> <p>}</p> <p>})</p> <h3 id="手写promise-all"><a href="#手写promise-all" class="header-anchor">#</a> 手写promise.all()</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">PromiseAll</span><span class="token punctuation">(</span><span class="token parameter">promiseArray</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">//返回一个Promise对象</span>
     <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>promiseArray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">//传入的参数是否为数组</span>
            <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'传入的参数不是数组！'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">0</span>                         <span class="token comment">//设置一个计数器</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promiseArray<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promiseArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                counter<span class="token operator">++</span>                  <span class="token comment">//使用计数器返回 必须使用counter</span>
                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> value
                <span class="token keyword">if</span> <span class="token punctuation">(</span>counter <span class="token operator">===</span> promiseArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// all合成的Promise返回所有子Promise的返回值数组</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="手写promise-race"><a href="#手写promise-race" class="header-anchor">#</a> 手写promise.race()</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">promiseRace</span><span class="token punctuation">(</span><span class="token parameter">promise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span> <span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span> <span class="token punctuation">(</span><span class="token string">&quot;promises must be an array!!!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token punctuation">}</span>
	<span class="token keyword">let</span> resolved <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">try</span><span class="token punctuation">{</span>
			promises<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">p</span> <span class="token operator">=&gt;</span>
                p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">data</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>resolved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                		resolved <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                		<span class="token function">resolve</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
                	<span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			<span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>注意promise中的resolve, reject和Promise.resolve()/Promise.reject()不同</strong></p> <h2 id="_13-async-await原理"><a href="#_13-async-await原理" class="header-anchor">#</a> 13. async/await原理</h2> <p>基于Promise实现的语法糖，作用是用<strong>同步的方式执行异步的操作</strong></p> <p>async和await是<strong>处理then链</strong>的语法糖</p> <p>在<code>async</code>函数中，<code>await</code>规定了异步操作只能一个一个排队执行，从而达到<strong>用同步方式，执行异步操作</strong>的效果，这里注意了：<strong>await只能在async函数中使用，不然会报错哦</strong></p> <p><strong>async声明function是异步的，await等待某个操作完成</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">await</span> <span class="token function">somethingThatReturnAPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//另一种写法</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">somethingThatReturnAPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>await 表达式的运算结果取决于它等的东西。</p> <p>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p> <p>如果它等到的是一个 Promise 对象，await 就忙起来了，它会<strong>阻塞</strong>后面的代码（会暂停async function执行。也就是说，必须得等待await后面的Promise处理完成才能继续），等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token keyword">function</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
   <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">testAwt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    
  <span class="token keyword">let</span> result <span class="token operator">=</span>  <span class="token keyword">await</span> <span class="token function">testAsy</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 3秒钟之后出现hello world</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'tangj'</span><span class="token punctuation">)</span>   <span class="token comment">// 3秒钟之后出现tangj</span>
<span class="token punctuation">}</span>
<span class="token function">testAwt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'tangSir'</span><span class="token punctuation">)</span>  <span class="token comment">//立即输出tangSir</span>
</code></pre></div><h2 id="_14-路由模式-hash和history"><a href="#_14-路由模式-hash和history" class="header-anchor">#</a> 14. 路由模式---hash和history</h2> <p>**hash（默认，#，监听hash值变化，onhashchange）：**路径用#拼接在真实URL后，当#后路径变化后浏览器不会重新发起请求，而是利用window可以监听onhashchange事件，根据hash值改变渲染指定DOM位置的不同数据，hash值不会作为路径一部分随着http请求发给服务器</p> <p>points---丑但是兼容性好</p> <p>**history(mode: 'history'，利用history API实现，会添加到浏览器历史记录栈，刷新404需要后端有对应接口)：**H5新特性，允许开发者直接更改路由，更新浏览器URL不重新发起请求。路径直接拼接在端口号后，所以后面的路径会随着http请求（页面刷新重新发送请求）发给服务器，因此前端URL必须和向发送请求后端URL一致否则报错，后端需要有对应接口，否则返回404</p> <p>api： pushState(路由压栈) replaceState(替换路由) back() forward() go(可负数字)</p> <p><strong>window.location.pathname</strong>可以获得路由地址</p> <p>window.onpopstate监听浏览器的前进和后退</p> <p>所以history容易遇到刷新404问题，可以通过nginx做代理转发，若参数中资源没找到则重新定向到首页</p> <h2 id="_15-防抖和节流"><a href="#_15-防抖和节流" class="header-anchor">#</a> 15. 防抖和节流</h2> <p><strong>防抖debounce（事件触发间隔需大于一定时间---重新计时）</strong>：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时</p> <p><strong>场景：input输入框</strong>不断输入值时，只最后请求一次，节约请求资源</p> <p><strong>节流throttle（指定事件间隔）</strong>：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。</p> <p><strong>场景：鼠标不断点击</strong>，减少其实际触发频率；滚动事件</p> <p>两者都是为了防止某一时间频繁触发，防抖是某一段时间只执行一次，节流是间隔时间执行一次（节流理解为游戏中按住射击时达到最大射速）</p> <h2 id="_16-执行栈和event-loop"><a href="#_16-执行栈和event-loop" class="header-anchor">#</a> 16. 执行栈和event loop</h2> <p>执行栈（同步任务）—-任务队列（异步任务）</p> <p>先同步任务再从event loop中读取结束等待状态的异步任务加入执行栈中恢复执行</p> <p>而任务队列中又分为宏任务和微任务，前者是每个阶段执行的任务，后者是每个阶段之间，执行一个宏，下一个宏之前会先把微清空</p> <p><strong>宏任务和微任务</strong></p> <p>宏：script(主程序代碼） setTimeout setInterval setImmediate I/O UI rendering</p> <p>微: nextTick Promises Object.observe MutationObserver</p> <p>主程序代码也属于宏，所以应该执行完同步后就清空微</p> <h2 id="_17-强缓存和协商缓存"><a href="#_17-强缓存和协商缓存" class="header-anchor">#</a> 17. 强缓存和协商缓存</h2> <p>HTTP缓存方式</p> <p>我们都知道当我们在浏览器中打开一个页面时，浏览器会根据你输入的URL到对应的服务器上请求你想要的数据资源。但这个过程中可能页面可能需要等待一段时间（白屏时间）才能渲染到你的页面中</p> <p>良好的缓存策略可以减低重复资源的请求，降低服务器的开销，提高用户页面的加载速度</p> <p>1，浏览器进行资源请求时，会判断response headers是否命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求，
2，当强缓存没有命中时，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如何不命中，服务器直接返回资源
区别： 强缓存命中，不会请求服务器，直接请求缓存；</p> <p>​		协商缓存命中，会请求服务器，不会返回内容，然后读取缓存</p> <h4 id="强缓存"><a href="#强缓存" class="header-anchor">#</a> <strong>强缓存</strong></h4> <p>分为<code>Expires</code>（http1.0规范）、<code>cache-control</code>（http1.1规范）两种</p> <p>在浏览器加载资源的时候，首先会根据请求头的<code>expires</code>和<code>cache-control</code>判断是否命中强缓存策略，判断是否向远程服务器请求资源还是去本地获取缓存资源</p> <p><strong>Expires</strong></p> <p>用于表示资源的过期时间的请求头字段，值是一个绝对时间</p> <p>浏览器进行第一次请求时，服务器会在返回头部加上Expires，下次请求，如果在这个时间之前则命中缓存</p> <p><strong>Cache-control</strong></p> <p><code>Expires</code>有个缺点，当客户端本地时间和服务器时间不一致时会产生误差，浏览器会直接向服务器请求新的资源</p> <p>为解决该问题在<code>http1.1</code>规范中，提出了<code>cache-control</code>字段，且<strong>这个字段优先级高于上面提到的Expires</strong>，值是相对时间</p> <p>利用max-age判断缓存的生命周期，是以秒为单位，如何在生命周期时间内，则命中缓存</p> <h4 id="协商缓存"><a href="#协商缓存" class="header-anchor">#</a> 协商缓存</h4> <p>涉及到两组字段成对出现的，在浏览器第一次发出请求时会带上字段（Last-Modified或者<code>Etag</code>），则后续请求则会带上对于的请求字段（<code>if-modified-since</code>或者<code>if-none-Match</code>），若响应头没有<code>Last-Modified</code>或者<code>Etag</code>，则请求头也不会有对应的字段</p> <p><strong>Last-Modified / If-Modified-Since</strong></p> <p>Last-Modified： 表示为为实体头部部分，response返回，表示为资源的最后更新时间
If-Modified-Since：通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源</p> <p><strong>Etag / If-None-Match</strong></p> <p>有些情况下仅判断最后修改日期来验证资源是否有改动是不够的：
1，存在周期性重写某些资源，但资源实际包含的内容并无变化；
2，被修改的信息并不重要，如注释等；
3，Last-Modified无法精确到毫秒，但有些资源更新频率有时会小于一秒。</p> <p>ETag:为相应头部字段，表示资源内容的唯一标识，随服务器response返回；
If-None-Match: 服务器比较请求头中的If-None-Match和当前资源中的etag是否一致，来判断资源是否修改过，如果没有修改，则命中缓存，浏览器从缓存中读取资源，如果修改过，服务器会返回新的etag，并返回资源</p> <p>ETag解决了Last-Modified使用时可能出现的资源的时间戳变了但内容没变及如果在一秒钟以内资源变化但Last-Modified没变的问题，感觉ETag更加稳妥</p> <p>补充：根据浏览器缓存策略，Expire和Cache-Control用<strong>回车、后退、F5刷新会跳过本地缓存</strong>，每次都会从服务器中获数据</p> <p><strong>Etag缺点</strong></p> <p>性能损耗！因为使用哈希算法生成内容标识，所以现在还是经常etag和last-modified一起用</p> <p><strong>状态码</strong></p> <p>200 请求成功，服务器返回全新的数据</p> <p>200 <code>from memory cache / from disk cache</code> 本地强缓存还在有效期，直接使用本地缓存</p> <p>304 请求成功，走了协商缓存，服务器判定（<code>Etag</code>和<code>Last-modified</code>）没有过期，告知浏览器使用缓存</p> <p><strong>优先级</strong></p> <p>Cache-control &gt; expires</p> <p>Etag &gt; last-modified</p></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_1-原型链和原型对象" class="sidebar-link reco-side-_1-原型链和原型对象" data-v-b57cc07c>1. 原型链和原型对象</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#引用类型" class="sidebar-link reco-side-引用类型" data-v-b57cc07c>引用类型</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_2-基本数据类型" class="sidebar-link reco-side-_2-基本数据类型" data-v-b57cc07c>2. 基本数据类型</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#symbol" class="sidebar-link reco-side-symbol" data-v-b57cc07c>Symbol</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#引用数据类型和基本数据类型区别" class="sidebar-link reco-side-引用数据类型和基本数据类型区别" data-v-b57cc07c>引用数据类型和基本数据类型区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#深拷贝和浅拷贝" class="sidebar-link reco-side-深拷贝和浅拷贝" data-v-b57cc07c>深拷贝和浅拷贝</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_3-闭包" class="sidebar-link reco-side-_3-闭包" data-v-b57cc07c>3. 闭包</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_4-var-let-const" class="sidebar-link reco-side-_4-var-let-const" data-v-b57cc07c>4. var let const</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#var-变量提升、可多次声明同一变量" class="sidebar-link reco-side-var-变量提升、可多次声明同一变量" data-v-b57cc07c>var---变量提升、可多次声明同一变量</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#let-块级声明、禁止重复声明" class="sidebar-link reco-side-let-块级声明、禁止重复声明" data-v-b57cc07c>let---块级声明、禁止重复声明</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#暂时性死区" class="sidebar-link reco-side-暂时性死区" data-v-b57cc07c>暂时性死区</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#const-常量、必须初始化、块级作用域" class="sidebar-link reco-side-const-常量、必须初始化、块级作用域" data-v-b57cc07c>const---常量、必须初始化、块级作用域</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#var相比let-const最大区别" class="sidebar-link reco-side-var相比let-const最大区别" data-v-b57cc07c>var相比let const最大区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#主要围绕以下五点" class="sidebar-link reco-side-主要围绕以下五点" data-v-b57cc07c>主要围绕以下五点</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_5-localstorage、sessionstorage-cookie、session区别" class="sidebar-link reco-side-_5-localstorage、sessionstorage-cookie、session区别" data-v-b57cc07c>5. localStorage、sessionStorage||cookie、session区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#cookie和session区别" class="sidebar-link reco-side-cookie和session区别" data-v-b57cc07c>cookie和session区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#cookie、localstorage和sessionstorage" class="sidebar-link reco-side-cookie、localstorage和sessionstorage" data-v-b57cc07c>cookie、localStorage和sessionStorage</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#如何实现可过期的localstorage" class="sidebar-link reco-side-如何实现可过期的localstorage" data-v-b57cc07c>如何实现可过期的localStorage</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_6-谈谈es6理解-新增属性" class="sidebar-link reco-side-_6-谈谈es6理解-新增属性" data-v-b57cc07c>6. 谈谈ES6理解，新增属性？</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_7-箭头函数和普通函数区别-围绕this、构造函数" class="sidebar-link reco-side-_7-箭头函数和普通函数区别-围绕this、构造函数" data-v-b57cc07c>7. 箭头函数和普通函数区别（围绕this、构造函数）</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_8-谈谈对promise的理解-异步-地狱、容器、三态、单向" class="sidebar-link reco-side-_8-谈谈对promise的理解-异步-地狱、容器、三态、单向" data-v-b57cc07c>8. 谈谈对promise的理解（异步-地狱、容器、三态、单向）</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_9-promise与async-await区别" class="sidebar-link reco-side-_9-promise与async-await区别" data-v-b57cc07c>9. promise与async/await区别</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_10-promise如何解决回调地狱问题" class="sidebar-link reco-side-_10-promise如何解决回调地狱问题" data-v-b57cc07c>10. promise如何解决回调地狱问题</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#回调地狱" class="sidebar-link reco-side-回调地狱" data-v-b57cc07c>回调地狱</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_11-promise详解" class="sidebar-link reco-side-_11-promise详解" data-v-b57cc07c>11. promise详解</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#解构promise对象-实质构造函数" class="sidebar-link reco-side-解构promise对象-实质构造函数" data-v-b57cc07c>解构Promise对象---实质构造函数</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#promise方法中all-和race-的区别" class="sidebar-link reco-side-promise方法中all-和race-的区别" data-v-b57cc07c>Promise方法中all()和race()的区别</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#手写promise-all" class="sidebar-link reco-side-手写promise-all" data-v-b57cc07c>手写promise.all()</a></li><li class="level-3" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#手写promise-race" class="sidebar-link reco-side-手写promise-race" data-v-b57cc07c>手写promise.race()</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_13-async-await原理" class="sidebar-link reco-side-_13-async-await原理" data-v-b57cc07c>13. async/await原理</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_14-路由模式-hash和history" class="sidebar-link reco-side-_14-路由模式-hash和history" data-v-b57cc07c>14. 路由模式---hash和history</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_15-防抖和节流" class="sidebar-link reco-side-_15-防抖和节流" data-v-b57cc07c>15. 防抖和节流</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_16-执行栈和event-loop" class="sidebar-link reco-side-_16-执行栈和event-loop" data-v-b57cc07c>16. 执行栈和event loop</a></li><li class="level-2" data-v-b57cc07c><a href="/9blog/blogs/%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86%E7%82%B9.html#_17-强缓存和协商缓存" class="sidebar-link reco-side-_17-强缓存和协商缓存" data-v-b57cc07c>17. 强缓存和协商缓存</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/9blog/assets/js/app.3e8fe7ca.js" defer></script><script src="/9blog/assets/js/3.4ae95a2d.js" defer></script><script src="/9blog/assets/js/1.ac641155.js" defer></script><script src="/9blog/assets/js/30.768ec0c1.js" defer></script>
  </body>
</html>
