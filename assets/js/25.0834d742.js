(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{424:function(t,s,a){"use strict";a.r(s);var n=a(2),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"react组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react组件通信"}},[t._v("#")]),t._v(" React组件通信")]),t._v(" "),s("p",[t._v("1、父传子props")]),t._v(" "),s("p",[t._v("2、子传父，在父组件中定义一个函数,然后传到子组件后进行调用")]),t._v(" "),s("p",[t._v("3、兄弟？---状态提升")]),t._v(" "),s("p",[t._v("react中其实不存在兄弟组件之间的传值,涉及到的兄弟组件之间的传值都会状态提升")]),t._v(" "),s("ul",[s("li",[t._v("将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态")]),t._v(" "),s("li",[t._v("思想："),s("strong",[t._v("状态提升")])]),t._v(" "),s("li",[t._v("公共父组件职责：\n"),s("ul",[s("li",[t._v("提供共享状态")]),t._v(" "),s("li",[t._v("提供操作共享状态的方法")])])]),t._v(" "),s("li",[t._v("要通讯的子组件只需通过 props 接收状态或操作状态的方法")])]),t._v(" "),s("p",[t._v("4、跨组件传值---create"),s("strong",[t._v("Context和Provider")])]),t._v(" "),s("p",[t._v("导入并调用createContext方法，得到Context对象，导出")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" createContext "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Context "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("使用 "),s("strong",[t._v("Provider")]),t._v(" 组件"),s("strong",[t._v("包裹根组件")]),t._v("，并通过 "),s("strong",[t._v("value")]),t._v(" 属性提供要共享的数据")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Context"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Provider value"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" 这里放要传递的数据 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("根组件的内容"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("Provider"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("在任意后代组件中，如果希望获取公共数据： 导入useContext；调用useContext(第一步中导出的context) 得到value的值")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" React"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" useContext "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react'")]),t._v("\n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Context "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./index'")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("函数组件")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" 公共数据 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Context"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" 函数组件的内容 "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("ol",[s("li",[t._v("redux")])]),t._v(" "),s("h2",{attrs:{id:"redux如何使用-几个关键因素"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redux如何使用-几个关键因素"}},[t._v("#")]),t._v(" Redux如何使用，几个关键因素？")]),t._v(" "),s("p",[t._v("reducer：接受两个参数，当前state和action，根据action操作state后返回newState")]),t._v(" "),s("p",[t._v("store：存储整个程序的状态")]),t._v(" "),s("p",[t._v("action：描述发生了什么事情的对象，触发state的更改")]),t._v(" "),s("p",[t._v("view：显示store提供的数据")]),t._v(" "),s("h2",{attrs:{id:"react生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react生命周期"}},[t._v("#")]),t._v(" React生命周期")]),t._v(" "),s("p",[t._v("只有 class 组件才有生命周期，因为 class 组件会创建对应的实例，而函数组件不会。组件实例从被创建到被销毁的过程称为"),s("strong",[t._v("组件的生命周期")])]),t._v(" "),s("p",[t._v("在 React 中，对于每一次由状态改变导致页面视图的改变，都会经历两个阶段："),s("code",[t._v("render 阶段")]),t._v("、"),s("code",[t._v("commit 阶段")])]),t._v(" "),s("p",[t._v("由 class 组件创建的实例具有生命周期，它的 render 函数在 render 阶段执行，并在此阶段进行 DOM 节点的 diff（diff 算法就是在此阶段进行的），找出需要改变的 DOM 操作。然后在 commit 阶段将对应的 DOM 操作提交至视图中")]),t._v(" "),s("p",[t._v("函数式组件没有state没有生命周期")]),t._v(" "),s("p",[t._v("函数式组件中"),s("strong",[t._v("模拟生命周期")])]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// componentDidMount")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// componentDidUpdate")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// componentWillUnMount")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useEffect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t  console"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'这是在渲染，只运行这一次'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\tconsole"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'Test组件死了'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\t  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// state")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" setState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("useState")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("initialState"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"react的setstate同步or异步"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react的setstate同步or异步"}},[t._v("#")]),t._v(" react的setState同步or异步？")]),t._v(" "),s("p",[t._v("同步代码异步表现，原因是"),s("strong",[t._v("react的批处理")]),t._v("。 react18之前在生命周期函数和合成事件中表现为异步，在原生事件中表现为同步。 在react18优化批处理之后，在任何地方调用setState都会批处理，因此"),s("strong",[t._v("都表现为异步")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"vue和react对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue和react对比"}},[t._v("#")]),t._v(" Vue和React对比？")]),t._v(" "),s("p",[t._v("react和vue大体上是相同的，比如都使用"),s("strong",[t._v("虚拟DOM")]),t._v("高效的更新视图，都提倡"),s("strong",[t._v("组件化")]),t._v("，都实现了"),s("strong",[t._v("数据驱动视图")]),t._v("，都使用"),s("strong",[t._v("diff算法")]),t._v("，也都对diff算法进行了优化，都有"),s("strong",[t._v("router")]),t._v("库实现url到组件的映射，都有状态管理等等.....")]),t._v(" "),s("p",[s("strong",[t._v("组件化(三位一体/all in js, jsx)+虚拟DOM(双指针双端比较/自顶向下)+diff算法+数据驱动视图(MVVM/setState)")])]),t._v(" "),s("p",[t._v("差异：")]),t._v(" "),s("h3",{attrs:{id:"组件化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[t._v("#")]),t._v(" 组件化")]),t._v(" "),s("p",[t._v("react：JSX + inline style，把html和css都写进js，all in js")]),t._v(" "),s("p",[t._v("vue：template的单文件组件格式，html、css和js在同一个文件中")]),t._v(" "),s("h3",{attrs:{id:"虚拟dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),s("p",[t._v("不管是vue的template模板+options api还是react的class或function写法最后都是生成render函数执行返回VNode(虚拟DOM的数据结构）")]),t._v(" "),s("p",[t._v("Vue2的核心Diff算法采用了"),s("strong",[t._v("双端比较")]),t._v("（双指针）的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法（"),s("strong",[t._v("自顶向下")]),t._v("），同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。")]),t._v(" "),s("p",[t._v("React 不能通过双端对比进行 Diff 算法优化是因为目前 Fiber 上没有设置反向链表，单链表无法使用双指针")]),t._v(" "),s("h3",{attrs:{id:"数据驱动视图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据驱动视图"}},[t._v("#")]),t._v(" 数据驱动视图")]),t._v(" "),s("p",[t._v("就是数据改变是相应视图也得到更新")]),t._v(" "),s("p",[t._v("Vue数据驱动通过"),s("strong",[t._v("MVVM框架")]),t._v("实现")]),t._v(" "),s("p",[t._v("遍历data---Object.defineProperty---\x3e转为getter/setter")]),t._v(" "),s("p",[t._v("同时每一个实例对象都由"),s("strong",[t._v("watcher")]),t._v("实例对象，模板编译时候就用getter访问data，watcher将data记为依赖建立视图与数据联系；")]),t._v(" "),s("p",[t._v("之后如果数据被setter调用，watcher对比数值变化通知视图渲染。")]),t._v(" "),s("h4",{attrs:{id:"vue数据双向绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue数据双向绑定"}},[t._v("#")]),t._v(" vue数据双向绑定")]),t._v(" "),s("p",[t._v("原理是通过"),s("strong",[t._v("数据劫持结合发布者-订阅者模式")]),t._v("的方式来实现的，首先是对数据进行监听，通过"),s("strong",[t._v("Object.defineProperty")]),t._v("来劫持数据的"),s("strong",[t._v("setter，getter")]),t._v("，然后当监听的属性发生变化时则告诉订阅者是否要更新，若更新就会执行对应的更新函数从而更新视图")]),t._v(" "),s("h5",{attrs:{id:"vue2-0双向绑定缺陷"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue2-0双向绑定缺陷"}},[t._v("#")]),t._v(" vue2.0双向绑定缺陷")]),t._v(" "),s("p",[t._v("不能监听对象的新增属性和删除属性（要使用vue.set()）；无法正确监听数组方法；只能监听对象单个属性，需要递归对所有属性监听")]),t._v(" "),s("h5",{attrs:{id:"vue3-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0"}},[t._v("#")]),t._v(" vue3.0")]),t._v(" "),s("p",[t._v("在Vue2.0的基础上将Object.defineProperty换成了功能更强大的proxy，原理相同，相比2.0能够动态监听添加的属性，可以监听数组的索引和length属性")]),t._v(" "),s("h4",{attrs:{id:"react数据单向绑定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react数据单向绑定"}},[t._v("#")]),t._v(" React数据单向绑定")]),t._v(" "),s("p",[t._v("react整体是函数式思想，即状态和逻辑为参数传入，单向数据流，数据驱动视图")]),t._v(" "),s("p",[t._v("React通过"),s("strong",[t._v("setState")]),t._v("实现数据驱动视图，通过setState来引发一次组件的更新过程从而实现页面的重新渲染")])])}),[],!1,null,null,null);s.default=e.exports}}]);