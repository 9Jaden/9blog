(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{439:function(v,_,e){"use strict";e.r(_);var t=e(2),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"设计模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式"}},[v._v("#")]),v._v(" 设计模式")]),v._v(" "),_("p",[v._v("主要是看观察者模式和发布-订阅模式")]),v._v(" "),_("p",[v._v("不同点：")]),v._v(" "),_("p",[v._v("主体数目不同2 vs. 3")]),v._v(" "),_("p",[v._v("观察者模式重点是被观察者Object，发布-订阅模式重点是发布订阅中心")]),v._v(" "),_("p",[v._v("观察者模式两者间有耦合（"),_("strong",[v._v("松耦合")]),v._v("？），而发布-订阅模式"),_("strong",[v._v("解耦")]),v._v("，灵活度高（适用于异步编程），因为观察者中被观察者除了实现自身功能还需要维护观察者列表，要包含一部分观察者和自身关系的逻辑。")]),v._v(" "),_("p",[v._v("而发布订阅模式中publisher和subscriber不需要知道对方的存在，publisher只需关心自己的发布逻辑(emit)，subscriber只需关心自己要注册接受通知的栏目(on)以及自己接受通知后的逻辑，发布订阅中心使得它们完全解耦，由eventChanel实现消息通知以及订阅注册。")]),v._v(" "),_("p",[v._v("vue的双向数据绑定是通过数据劫持的发布订阅模式实现")]),v._v(" "),_("h3",{attrs:{id:"观察者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[v._v("#")]),v._v(" 观察者模式")]),v._v(" "),_("p",[v._v("当对象之间存在"),_("strong",[v._v("一对多")]),v._v("的依赖关系时，其中一个对象的状态发生改变，所有依赖它的对象都会收到通知，这就是观察者模式")]),v._v(" "),_("p",[v._v("在观察者模式中，只有两种主体：目标对象 ("),_("code",[v._v("Object")]),v._v(") 和 观察者 ("),_("code",[v._v("Observer")]),v._v(")")]),v._v(" "),_("p",[v._v("目标对象 "),_("code",[v._v("Object")])]),v._v(" "),_("ul",[_("li",[v._v("维护观察者列表 "),_("code",[v._v("observerList")])]),v._v(" "),_("li",[v._v("定义添加观察者的方法")]),v._v(" "),_("li",[v._v("当自身发生变化后，通过调用自己的 "),_("code",[v._v("notify")]),v._v(" 方法依次通知每个观察者执行 "),_("code",[v._v("update")]),v._v(" 方法")])]),v._v(" "),_("p",[v._v("观察者 "),_("code",[v._v("Observer")]),v._v(" 需要实现 "),_("code",[v._v("update")]),v._v(" 方法，供目标对象调用。"),_("code",[v._v("update")]),v._v("方法中可以执行自定义的业务逻辑")]),v._v(" "),_("h3",{attrs:{id:"发布-订阅模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#发布-订阅模式"}},[v._v("#")]),v._v(" 发布-订阅模式")]),v._v(" "),_("p",[v._v("基于一个事件（主题）通道，希望接收通知的对象 "),_("code",[v._v("Subscriber")]),v._v(" 通过自定义事件订阅主题，被激活事件的对象 "),_("code",[v._v("Publisher")]),v._v(" 通过发布主题事件的方式通知各个订阅该主题的 "),_("code",[v._v("Subscriber")]),v._v(" 对象")]),v._v(" "),_("p",[v._v("发布订阅模式与观察者模式相比，发布订阅模式中有"),_("strong",[v._v("三个角色")]),v._v("，发布者 "),_("code",[v._v("Publisher")]),v._v(" ，事件调度中心 "),_("code",[v._v("Event Channel")]),v._v(" ，订阅者 "),_("code",[v._v("Subscriber")])]),v._v(" "),_("p",[v._v("发布者—— "),_("code",[v._v("Publisher")])]),v._v(" "),_("p",[v._v("事件调度中心——"),_("code",[v._v("Event Channel")])]),v._v(" "),_("ul",[_("li",[v._v("维护任务类型，以及每种任务下的订阅情况")]),v._v(" "),_("li",[v._v("给订阅者提供订阅功能 —— "),_("code",[v._v("subscribe")]),v._v(" 功能")]),v._v(" "),_("li",[v._v("当Publisher发布任务后，调度中心会给所有的订阅者发布任务 —— "),_("code",[v._v("publish")]),v._v(" 功能")])]),v._v(" "),_("p",[v._v("订阅者—— "),_("code",[v._v("Subscriber")])]),v._v(" "),_("p",[_("strong",[v._v("发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("设计模式")]),v._v(" "),_("th",[v._v("观察者模式")]),v._v(" "),_("th",[v._v("发布订阅模式")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("主体")]),v._v(" "),_("td",[v._v("Object观察者、Subject目标对象")]),v._v(" "),_("td",[v._v("Publisher发布者、Event Channel事件中心、Subscribe订阅者")])]),v._v(" "),_("tr",[_("td",[v._v("主体关系")]),v._v(" "),_("td",[v._v("Subject中通过observerList记录ObServer")]),v._v(" "),_("td",[v._v("Publisher和Subscribe不想不知道对方，通过中介联系")])]),v._v(" "),_("tr",[_("td",[v._v("优点")]),v._v(" "),_("td",[v._v("角色明确，Subject和Object要遵循约定的成员方法")]),v._v(" "),_("td",[v._v("解耦合，灵活度高，通常应用在异步编程中")])]),v._v(" "),_("tr",[_("td",[v._v("缺点")]),v._v(" "),_("td",[v._v("松耦合")]),v._v(" "),_("td",[v._v("当事件类型变多时，会增加维护成本")])]),v._v(" "),_("tr",[_("td",[v._v("使用案例")]),v._v(" "),_("td",[v._v("双向数据绑定")]),v._v(" "),_("td",[v._v("事件总线EventBus")])])])]),v._v(" "),_("h2",{attrs:{id:"mvvm-mvc-mvp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-mvc-mvp"}},[v._v("#")]),v._v(" MVVM & MVC & MVP")]),v._v(" "),_("p",[_("strong",[v._v("MVVM")])]),v._v(" "),_("p",[v._v("Vuejs的"),_("strong",[v._v("数据驱动视图")]),v._v("是通过MVVM这种框架来实现的。MVVM框架主要包含3个部分:model、view和 viewModel。")]),v._v(" "),_("ul",[_("li",[v._v("Model(模型):指的是数据部分，对应到前端就是javascript对象")]),v._v(" "),_("li",[v._v("View(视图):指的是页面结构、布局、外观(UI)，对应前端就是dom")]),v._v(" "),_("li",[v._v("ViewModel(视图模型):就是连接视图与数据的中间件，暴露公共属性和命令的视图的抽象")])]),v._v(" "),_("p",[v._v("ViewModel是实现数据驱动视图的核心，当数据变化的时候，ViewModel能够监听到这种变化，并及时的通知view做出修改。同样的，当页面有事件触发时，ViewModel也能够监听到事件，并通知model进行响应。ViewModel就相当于一个观察者，监控着双方的动作，并及时通知对方进行相应的操作。")]),v._v(" "),_("p",[_("strong",[v._v("MVC")])]),v._v(" "),_("p",[v._v("C为controller，控制器，处理输入--业务逻辑")]),v._v(" "),_("p",[v._v("通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据")]),v._v(" "),_("p",[_("strong",[v._v("MVP")])]),v._v(" "),_("p",[v._v("从经典MVC模式演变而来，P为Presenter，同样负责逻辑的处理")]),v._v(" "),_("p",[v._v("模型和视图完全分离，所有交互都发生在Presenter，更加高效")]),v._v(" "),_("p",[_("strong",[v._v("MVP和MVVM区别")])]),v._v(" "),_("p",[v._v("MVVM采用双向绑定")]),v._v(" "),_("h3",{attrs:{id:"mvc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[v._v("#")]),v._v(" MVC")]),v._v(" "),_("p",[v._v("该软件是由JavaScript，HTML，CSS编写的的网页游戏，其中主要逻辑算法由JavaScript完成。而其软件架构为MVC模式")]),v._v(" "),_("h4",{attrs:{id:"控制层-controller"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#控制层-controller"}},[v._v("#")]),v._v(" 控制层（Controller）")]),v._v(" "),_("p",[v._v("JavaScript是一门事件驱动型的语言，通过在网页的特定DOM中绑定相应的事件监听，当用户在界面上特定的DOM元素上进行特定操作时就会触发对应的事件监听函数时，对逻辑进行处理。")]),v._v(" "),_("h4",{attrs:{id:"视图-view"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#视图-view"}},[v._v("#")]),v._v(" 视图（View）")]),v._v(" "),_("p",[v._v("该软件的界面由HTML和CSS决定，文件夹中的index.html和style.css会在浏览器的运行下生成对应的DOM树与样式，并在浏览器上渲染出界面。Js可以修改DOM树和样式，从而改变视图。")]),v._v(" "),_("h4",{attrs:{id:"模型-model"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模型-model"}},[v._v("#")]),v._v(" 模型（Model）")]),v._v(" "),_("p",[v._v("sudu.js和index.js文件中保存着实现处理事件的对应代码。而数据保存在浏览器的localstorage中。因为由于规定对浏览器的限制，浏览器只能读取本地文件，却不能修改本地文件，所以在不使用服务器的情况下，本软件通过浏览器的localstorage来保存修改成绩。")]),v._v(" "),_("h2",{attrs:{id:"模块化-组件化-工程化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化-组件化-工程化"}},[v._v("#")]),v._v(" 模块化 组件化 工程化")]),v._v(" "),_("p",[v._v("复用、分治----"),_("strong",[v._v("JS/CSS模块化、UI组件化")])]),v._v(" "),_("p",[v._v("模块化：JS功能、css样式进行模块化编写,既能实现复用还可以分而治之（比如vuex中对于每一个组件设立单独的仓库文件，后在index.js中引入各个模块modules）")]),v._v(" "),_("p",[v._v("组件化：组件化将页面视为一个容器,页面上各个独立部分例如:头部、导航、焦点图、侧边栏、底部等视为独立组件,不同的页面根据内容的需要,去盛放相关组件即可组成完整的页面。")]),v._v(" "),_("p",[v._v("工程化：模块化和组件化是工程化的表现形式，最早的“结构、样式和动作分离”")]),v._v(" "),_("p",[v._v("UI页面拆分成有模板+样式+逻辑组成的功能单元，称为组件，组件化不等于模块化，模块化是在资源和代码方面对文件的拆分，而组件化是在UI层面进行的拆分")])])}),[],!1,null,null,null);_.default=r.exports}}]);